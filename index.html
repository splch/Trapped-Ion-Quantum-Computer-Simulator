<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Trapped‑Ion Quantum Computer Digital Twin (171Yb+ • pulse‑level • no dense state‑vector)</title>
<style>
  :root{
    --bg:#0b0f14;
    --panel:#101823;
    --panel2:#0e1520;
    --ink:#e8eef7;
    --muted:#a9b7c9;
    --faint:#6f8299;
    --accent:#7bdcff;
    --accent2:#9dffbf;
    --warn:#ffd27b;
    --bad:#ff7b95;
    --ok:#9dffbf;
    --line:#1b2a3d;
    --shadow: 0 14px 40px rgba(0,0,0,.45);
    --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    margin:0;
    font-family:var(--sans);
    background: radial-gradient(1200px 700px at 20% 0%, rgba(123,220,255,.14), transparent 55%),
                radial-gradient(900px 500px at 75% 10%, rgba(157,255,191,.10), transparent 60%),
                radial-gradient(1400px 900px at 50% 120%, rgba(155,125,255,.10), transparent 60%),
                var(--bg);
    color:var(--ink);
  }
  header{
    padding:18px 20px 12px;
    border-bottom:1px solid var(--line);
    position:sticky; top:0; z-index:10;
    backdrop-filter: blur(10px);
    background: rgba(11,15,20,.72);
  }
  header h1{
    margin:0;
    font-size:18px;
    letter-spacing:.2px;
    display:flex; gap:10px; align-items:center;
  }
  header .subtitle{
    margin-top:6px;
    color:var(--muted);
    font-size:12.5px;
    line-height:1.35;
  }
  .badge{
    font-size:11px;
    padding:3px 8px;
    border:1px solid rgba(123,220,255,.35);
    color:var(--accent);
    border-radius:999px;
    background: rgba(123,220,255,.08);
    white-space:nowrap;
  }
  .wrap{
    display:grid;
    grid-template-columns: 410px 1fr;
    gap:14px;
    padding:14px;
    max-width: 1600px;
    margin:0 auto;
  }
  .panel{
    background: linear-gradient(180deg, rgba(255,255,255,.03), rgba(255,255,255,.01));
    border:1px solid var(--line);
    border-radius:14px;
    box-shadow: var(--shadow);
    overflow:hidden;
  }
  .panel .hd{
    padding:12px 14px;
    border-bottom:1px solid var(--line);
    display:flex; align-items:center; justify-content:space-between;
    background: rgba(255,255,255,.02);
  }
  .panel .hd h2{
    margin:0;
    font-size:13px;
    letter-spacing:.2px;
    color:var(--ink);
    display:flex; align-items:center; gap:10px;
  }
  .panel .bd{
    padding:12px 14px;
  }
  .grid2{display:grid; grid-template-columns:1fr 1fr; gap:10px;}
  .grid3{display:grid; grid-template-columns:1fr 1fr 1fr; gap:10px;}
  .row{display:flex; align-items:center; justify-content:space-between; gap:10px; margin:8px 0;}
  label{font-size:12px; color:var(--muted);}
  input[type="range"]{width:180px;}
  input[type="number"], input[type="text"], select, textarea{
    background: rgba(0,0,0,.25);
    border:1px solid rgba(255,255,255,.08);
    color:var(--ink);
    border-radius:10px;
    padding:8px 10px;
    outline:none;
    font-size:12px;
  }
  textarea{width:100%; min-height: 230px; resize: vertical; font-family:var(--mono); line-height:1.35;}
  .btns{display:flex; flex-wrap:wrap; gap:8px;}
  button{
    cursor:pointer;
    border:1px solid rgba(255,255,255,.10);
    background: rgba(255,255,255,.05);
    color:var(--ink);
    padding:8px 10px;
    border-radius:12px;
    font-size:12px;
    transition: transform .05s ease, background .2s ease, border .2s ease;
  }
  button:hover{background: rgba(255,255,255,.08); border-color: rgba(123,220,255,.25);}
  button:active{transform: translateY(1px);}
  button.primary{
    border-color: rgba(123,220,255,.35);
    background: rgba(123,220,255,.11);
    color: var(--accent);
  }
  button.good{
    border-color: rgba(157,255,191,.35);
    background: rgba(157,255,191,.11);
    color: var(--accent2);
  }
  button.warn{
    border-color: rgba(255,210,123,.40);
    background: rgba(255,210,123,.10);
    color: var(--warn);
  }
  .tiny{font-size:11px; color:var(--muted);}
  .mono{font-family:var(--mono);}
  .kv{
    display:grid;
    grid-template-columns: 1fr auto;
    gap:6px 10px;
    font-size:12px;
    color:var(--muted);
    padding:10px 12px;
    background: rgba(0,0,0,.18);
    border:1px solid rgba(255,255,255,.06);
    border-radius:12px;
  }
  .kv b{color:var(--ink); font-weight:600;}
  .ok{color:var(--ok);}
  .bad{color:var(--bad);}
  .warnTxt{color:var(--warn);}
  .sep{height:1px; background: var(--line); margin:10px 0;}
  canvas{
    width:100%;
    height: 220px;
    background: radial-gradient(900px 260px at 20% 0%, rgba(123,220,255,.10), transparent 60%),
                rgba(0,0,0,.18);
    border:1px solid rgba(255,255,255,.06);
    border-radius:14px;
  }
  .stack{display:grid; gap:10px;}
  .pill{
    display:inline-flex; align-items:center; gap:8px;
    padding:6px 10px;
    border-radius:999px;
    border:1px solid rgba(255,255,255,.10);
    background: rgba(0,0,0,.18);
    font-size:12px;
    color:var(--muted);
  }
  .pill .dot{width:9px; height:9px; border-radius:50%;}
  .log{
    font-family:var(--mono);
    font-size:11.5px;
    line-height:1.35;
    color:#dbe7ff;
    background: rgba(0,0,0,.25);
    border:1px solid rgba(255,255,255,.06);
    border-radius:12px;
    padding:10px 10px;
    max-height: 170px;
    overflow:auto;
    white-space: pre-wrap;
  }
  table{width:100%; border-collapse:collapse; font-size:12px;}
  th,td{border-bottom:1px solid rgba(255,255,255,.06); padding:7px 6px; text-align:left; color:var(--muted);}
  th{color:var(--ink); font-weight:600;}
  td b{color:var(--ink);}
  .rightGrid{
    display:grid;
    grid-template-columns: 1fr 1fr;
    gap:14px;
  }
  @media (max-width: 1100px){
    .wrap{grid-template-columns:1fr}
    .rightGrid{grid-template-columns:1fr}
  }
</style>
</head>
<body>
<header>
  <h1>
    Trapped‑Ion Quantum Computer Digital Twin <span class="badge">171Yb+ • pulse‑level • no dense state‑vector</span>
  </h1>
  <div class="subtitle">
    A browser‑only “lab workflow + control stack + readout” simulator. Quantum evolution is simulated using a <b>stabilizer tableau</b>
    (Clifford circuits) with a <b>stochastic physical error model</b> (dephasing, depolarizing, motional heating, SPAM).<br/>
    This intentionally avoids a dense 2<sup>n</sup> state‑vector array; it behaves like real hardware: you get <b>shots</b>, not amplitudes.
  </div>
</header>

<div class="wrap">
  <!-- LEFT: controls -->
  <div class="panel">
    <div class="hd"><h2>Lab Console</h2><div class="pill"><span class="dot" id="dotReady"></span><span id="readyTxt">Not ready</span></div></div>
    <div class="bd stack">
      <div class="kv" id="kvSummary">
        <div>Vacuum pressure</div><div><b id="kvPressure"></b></div>
        <div>Oven temperature</div><div><b id="kvOven"></b></div>
        <div>Trap RF</div><div><b id="kvRF"></b></div>
        <div>Axial secular ωz/2π</div><div><b id="kvWz"></b></div>
        <div>Ions loaded</div><div><b id="kvIons"></b></div>
        <div>Motional n̄ (axial)</div><div><b id="kvNbar"></b></div>
      </div>

      <div class="panel" style="box-shadow:none;">
        <div class="hd"><h2>Setup & Environment</h2><span class="tiny">pumpdown • oven • loading</span></div>
        <div class="bd">
          <div class="row"><label>Target pressure (Torr)</label>
            <select id="selBaseP">
              <option value="1e-10">1e‑10 (OK)</option>
              <option value="1e-11" selected>1e‑11 (UHV)</option>
              <option value="3e-12">3e‑12 (excellent)</option>
            </select>
          </div>
          <div class="row"><label>Pump speed (arb.)</label>
            <input id="rngPump" type="range" min="0.2" max="3.0" step="0.1" value="1.2"/>
            <span class="mono" id="txtPump"></span>
          </div>
          <div class="row"><label>Oven setpoint (°C)</label>
            <input id="rngOven" type="range" min="200" max="550" step="10" value="450"/>
            <span class="mono" id="txtOvenSet"></span>
          </div>
          <div class="row"><label>Photoionization (399+369)</label>
            <select id="selPI">
              <option value="off">OFF</option>
              <option value="on">ON</option>
            </select>
          </div>
          <div class="btns">
            <button id="btnPump" class="primary">Pump down</button>
            <button id="btnBake" class="warn">Bakeout</button>
            <button id="btnOven" class="primary">Heat oven</button>
            <button id="btnLoad" class="good">Load ions</button>
            <button id="btnCool" class="primary">Cool (Doppler → sideband)</button>
          </div>
          <div class="tiny" style="margin-top:8px;">
            Realistic defaults are modeled on common 171Yb+ experiments (photoionization via 398.91 nm + 369.53 nm; cooling/detection on 369.53 nm with 935.2 nm repump). See citations in the assistant message.
          </div>
        </div>
      </div>

      <div class="panel" style="box-shadow:none;">
        <div class="hd"><h2>Trap & Qubit Parameters</h2><span class="tiny">RF Paul trap • clock qubit</span></div>
        <div class="bd">
          <div class="grid2">
            <div>
              <label>Number of ions (qubits)</label><br/>
              <input id="numQ" type="number" min="1" max="16" value="2" style="width:100%;"/>
            </div>
            <div>
              <label>RF drive Ωrf/2π (MHz)</label><br/>
              <input id="numRFf" type="number" min="10" max="80" step="1" value="37" style="width:100%;"/>
            </div>
            <div>
              <label>RF Vpp (V)</label><br/>
              <input id="numRFv" type="number" min="50" max="500" step="10" value="200" style="width:100%;"/>
            </div>
            <div>
              <label>Axial ωz/2π (MHz)</label><br/>
              <input id="numWz" type="number" min="0.1" max="1.5" step="0.05" value="0.20" style="width:100%;"/>
            </div>
            <div>
              <label>Radial ωr/2π (MHz)</label><br/>
              <input id="numWr" type="number" min="1" max="6" step="0.1" value="1.0" style="width:100%;"/>
            </div>
            <div>
              <label>B‑field (Gauss)</label><br/>
              <input id="numB" type="number" min="0" max="15" step="0.5" value="6" style="width:100%;"/>
            </div>
          </div>
          <div class="sep"></div>
          <div class="grid2">
            <div>
              <label>Motional heating (quanta/s)</label><br/>
              <input id="numHeat" type="number" min="0" max="2000" step="10" value="50" style="width:100%;"/>
            </div>
            <div>
              <label>Qubit T2 (s)</label><br/>
              <input id="numT2" type="number" min="0.01" max="10000" step="0.1" value="2.5" style="width:100%;"/>
            </div>
            <div>
              <label>1Q gate infidelity</label><br/>
              <input id="numP1" type="number" min="0" max="0.05" step="0.0001" value="0.0010" style="width:100%;"/>
            </div>
            <div>
              <label>2Q gate infidelity</label><br/>
              <input id="numP2" type="number" min="0" max="0.20" step="0.0001" value="0.0100" style="width:100%;"/>
            </div>
          </div>
          <div class="tiny" style="margin-top:8px;">Gate errors are applied as stochastic Pauli channels (Pauli‑twirled approximation) + continuous dephasing from T2 during pulse durations.</div>
        </div>
      </div>

      <div class="panel" style="box-shadow:none;">
        <div class="hd"><h2>Pulse Program</h2><span class="tiny">laser pulses → compiled to calibrated Clifford ops</span></div>
        <div class="bd">
          <div class="row">
            <label>Template</label>
            <select id="selTemplate">
              <option value="bell" selected>Bell state (2 ions, MS + virtual phase)</option>
              <option value="ghz">GHZ (N ions, chained entanglement)</option>
              <option value="bv">Bernstein–Vazirani (N-1 data + 1 ancilla)</option>
              <option value="randcliff">Random Clifford benchmark</option>
              <option value="blank">Blank</option>
            </select>
          </div>
          <textarea id="txtProgram" spellcheck="false"></textarea>
          <div class="row">
            <label>Shots</label>
            <input id="numShots" type="number" min="1" max="20000" step="10" value="1000"/>
          </div>
          <div class="btns">
            <button id="btnCompile" class="primary">Validate / compile</button>
            <button id="btnRun" class="good">Run program</button>
            <button id="btnReset" class="warn">Reset lab</button>
          </div>
          <div class="tiny" style="margin-top:8px;">
            Supported ops (pulse‑level): <span class="mono">PUMP_DOWN</span>, <span class="mono">OVEN</span>, <span class="mono">PI</span>, <span class="mono">DOPPLER</span>, <span class="mono">SIDEBAND</span>, <span class="mono">OPTPUMP</span>, <span class="mono">RAMAN</span>, <span class="mono">MS</span>, <span class="mono">VZ</span>, <span class="mono">MEASURE</span>.<br/>
            Gate compilation is Clifford‑calibrated (π/2 rotations, maximally entangling MS). Non‑Clifford angles are <b>rounded</b> and logged.
          </div>
        </div>
      </div>

      <div class="panel" style="box-shadow:none;">
        <div class="hd"><h2>Log</h2><span class="tiny">what the control computer did</span></div>
        <div class="bd">
          <div class="log" id="log"></div>
        </div>
      </div>
    </div>
  </div>

  <!-- RIGHT: visuals -->
  <div class="stack">
    <div class="rightGrid">
      <div class="panel">
        <div class="hd"><h2>Vacuum, Oven, Trap</h2><span class="tiny">environmental state</span></div>
        <div class="bd stack">
          <canvas id="cvEnv" width="900" height="440"></canvas>
          <div class="tiny">Gauge: pressure (log), oven temperature ramp, RF/axial frequencies, and a simple collision‑risk estimator.</div>
        </div>
      </div>

      <div class="panel">
        <div class="hd"><h2>Ion Chain & Modes</h2><span class="tiny">Coulomb crystal + motion</span></div>
        <div class="bd stack">
          <canvas id="cvIons" width="900" height="440"></canvas>
          <div class="tiny">Ion positions are computed by minimizing the 1D harmonic + Coulomb potential. Motional n̄ evolves under cooling/heating; it affects MS gate error in the model.</div>
        </div>
      </div>

      <div class="panel">
        <div class="hd"><h2>Pulse Timeline</h2><span class="tiny">AOM/EOM pulses (schematic)</span></div>
        <div class="bd stack">
          <canvas id="cvPulse" width="900" height="440"></canvas>
          <div class="tiny">Timeline shows pulse blocks with durations; Raman and MS pulses include the model’s dephasing window and motional heating during the pulse.</div>
        </div>
      </div>

      <div class="panel">
        <div class="hd"><h2>Readout</h2><span class="tiny">photon counts → threshold → bits</span></div>
        <div class="bd stack">
          <canvas id="cvReadout" width="900" height="440"></canvas>
          <div class="grid2">
            <div>
              <label>Detection time (µs)</label><br/>
              <input id="numDetT" type="number" min="10" max="5000" step="10" value="300" style="width:100%;"/>
            </div>
            <div>
              <label>PMT bright mean (counts)</label><br/>
              <input id="numBright" type="number" min="1" max="200" step="1" value="25" style="width:100%;"/>
            </div>
            <div>
              <label>PMT dark mean (counts)</label><br/>
              <input id="numDark" type="number" min="0" max="20" step="0.1" value="1.0" style="width:100%;"/>
            </div>
            <div>
              <label>Threshold (counts)</label><br/>
              <input id="numThresh" type="number" min="0" max="200" step="1" value="10" style="width:100%;"/>
            </div>
          </div>
          <div class="tiny">Photon counts are simulated as Poisson with background; thresholding yields SPAM error. You can tune these to match your detector / NA.</div>
        </div>
      </div>
    </div>

    <div class="panel">
      <div class="hd"><h2>Measurement Distribution</h2><span class="tiny">bitstrings from shots</span></div>
      <div class="bd">
        <table>
          <thead><tr><th>Bitstring</th><th>Counts</th><th>Probability</th></tr></thead>
          <tbody id="tblOut"></tbody>
        </table>
        <div class="tiny" style="margin-top:8px;">In a Bell experiment you should see mostly 00 and 11 (after phase correction), with small leakage set by your gate+readout settings.</div>
      </div>
    </div>
  </div>
</div>

<script>
/* ============================================================
   Trapped‑ion digital twin: pulse‑level + stabilizer simulator
   ------------------------------------------------------------
   - Quantum: Aaronson‑Gottesman stabilizer tableau (Cliffords)
   - Noise: shot‑wise stochastic Pauli errors + dephasing + SPAM
   - Motion: scalar n̄ with Doppler/sideband cooling and heating
   - Lab: UHV pumpdown + oven heating + photoionization loading
   ============================================================ */

// ---------- Utilities ----------
const TAU = Math.PI * 2;

function clamp(x,a,b){ return Math.max(a, Math.min(b, x)); }
function lerp(a,b,t){ return a + (b-a)*t; }
function fmt(x, digits=3){
  if (!isFinite(x)) return "—";
  const abs = Math.abs(x);
  if (abs === 0) return "0";
  if (abs >= 1e6 || abs < 1e-3) return x.toExponential(digits);
  return x.toFixed(digits);
}
function fmtSI(x, unit){
  // crude SI prefix formatting
  const abs = Math.abs(x);
  const prefixes = [
    {p:1e-12,s:"p"},
    {p:1e-9,s:"n"},
    {p:1e-6,s:"µ"},
    {p:1e-3,s:"m"},
    {p:1,s:""},
    {p:1e3,s:"k"},
    {p:1e6,s:"M"},
    {p:1e9,s:"G"},
  ];
  let best = prefixes[4];
  for (const pr of prefixes){
    if (abs >= pr.p) best = pr;
  }
  return (x/best.p).toFixed(3) + " " + best.s + unit;
}
function choice(arr){ return arr[Math.floor(Math.random()*arr.length)]; }

// Gaussian (Box‑Muller)
function randn(){
  let u=0,v=0;
  while(u===0) u=Math.random();
  while(v===0) v=Math.random();
  return Math.sqrt(-2*Math.log(u))*Math.cos(TAU*v);
}

// Poisson sampler (Knuth for small, normal approx for large)
function poisson(lambda){
  lambda = Math.max(0, lambda);
  if (lambda < 30){
    const L = Math.exp(-lambda);
    let k=0, p=1;
    while(p > L){
      k++;
      p *= Math.random();
    }
    return k-1;
  }else{
    // normal approx
    const x = lambda + Math.sqrt(lambda)*randn();
    return Math.max(0, Math.round(x));
  }
}

// ---------- Stabilizer Tableau (Aaronson‑Gottesman) ----------
// Uses bitmasks (n<=16 fits in 32-bit)
class Stabilizer {
  constructor(n){
    this.n = n;
    this.rows = 2*n + 1;          // last row is scratch
    this.x = new Uint32Array(this.rows); // X bits
    this.z = new Uint32Array(this.rows); // Z bits
    this.r = new Uint8Array(this.rows);  // phase bit (0:+,1:-)
    this.resetToZero();
  }
  resetToZero(){
    const n = this.n;
    const R = 2*n;
    for (let i=0;i<this.rows;i++){
      this.x[i]=0; this.z[i]=0; this.r[i]=0;
    }
    // destabilizers: X_i
    for (let i=0;i<n;i++){
      this.x[i] = (1<<i);
    }
    // stabilizers: Z_i
    for (let i=0;i<n;i++){
      this.z[i+n] = (1<<i);
    }
    // scratch row all zero
    this.x[R]=0; this.z[R]=0; this.r[R]=0;
  }
  clone(){
    const c = new Stabilizer(this.n);
    c.x.set(this.x);
    c.z.set(this.z);
    c.r.set(this.r);
    return c;
  }
  // g function from Aaronson‑Gottesman (returns -1,0,1)
  static g(x1,z1,x2,z2){
    if (x1===0 && z1===0) return 0;
    if (x1===1 && z1===1) return (z2 - x2);
    if (x1===1 && z1===0) return z2 * (2*x2 - 1);
    // x1==0 && z1==1
    return x2 * (1 - 2*z2);
  }
  // rowsum(h, i): row h = row i * row h
  rowsum(h,i){
    const n = this.n;
    let sum = 2*this.r[h] + 2*this.r[i]; // sum mod4
    for (let j=0;j<n;j++){
      const mask = (1<<j);
      const x1 = (this.x[i] & mask) ? 1 : 0;
      const z1 = (this.z[i] & mask) ? 1 : 0;
      const x2 = (this.x[h] & mask) ? 1 : 0;
      const z2 = (this.z[h] & mask) ? 1 : 0;
      sum += Stabilizer.g(x1,z1,x2,z2);
    }
    // mod 4 in [0,3]
    sum = ((sum % 4) + 4) % 4;
    if (sum !== 0 && sum !== 2){
      // should never happen for tableau invariants
      // but clamp defensively
      sum = (sum & 2);
    }
    this.r[h] = (sum===0) ? 0 : 1;
    this.x[h] ^= this.x[i];
    this.z[h] ^= this.z[i];
  }
  hGate(a){
    const mask = (1<<a);
    for (let i=0;i<2*this.n;i++){
      const xi = (this.x[i] & mask) ? 1 : 0;
      const zi = (this.z[i] & mask) ? 1 : 0;
      if (xi && zi) this.r[i] ^= 1;
      // swap x and z bit at a
      const xbit = this.x[i] & mask;
      const zbit = this.z[i] & mask;
      this.x[i] = (this.x[i] & ~mask) | zbit;
      this.z[i] = (this.z[i] & ~mask) | xbit;
    }
  }
  sGate(a){
    const mask = (1<<a);
    for (let i=0;i<2*this.n;i++){
      const xi = (this.x[i] & mask) ? 1 : 0;
      const zi = (this.z[i] & mask) ? 1 : 0;
      if (xi && zi) this.r[i] ^= 1;
      // z ^= x
      if (xi) this.z[i] ^= mask;
    }
  }
  sdgGate(a){ this.sGate(a); this.sGate(a); this.sGate(a); }
  cnot(c,t){
    const mC = (1<<c);
    const mT = (1<<t);
    for (let i=0;i<2*this.n;i++){
      const xc = (this.x[i] & mC) ? 1 : 0;
      const zc = (this.z[i] & mC) ? 1 : 0;
      const xt = (this.x[i] & mT) ? 1 : 0;
      const zt = (this.z[i] & mT) ? 1 : 0;
      if (xc && zt && ((xt ^ zc ^ 1)===1)) this.r[i] ^= 1;
      // x_t ^= x_c
      if (xc) this.x[i] ^= mT;
      // z_c ^= z_t
      if (zt) this.z[i] ^= mC;
    }
  }
  // Pauli gates (Clifford) as sign flips
  xGate(a){
    const mask = (1<<a);
    for (let i=0;i<2*this.n;i++){
      if (this.z[i] & mask) this.r[i] ^= 1; // Z or Y flips sign
    }
  }
  zGate(a){
    const mask = (1<<a);
    for (let i=0;i<2*this.n;i++){
      if (this.x[i] & mask) this.r[i] ^= 1; // X or Y flips sign
    }
  }
  yGate(a){
    const mask = (1<<a);
    for (let i=0;i<2*this.n;i++){
      const xi = (this.x[i] & mask) ? 1 : 0;
      const zi = (this.z[i] & mask) ? 1 : 0;
      if (xi ^ zi) this.r[i] ^= 1; // flips sign for X or Z
    }
  }

  // Measurement in Z basis: returns 0/1 and collapses.
  measureZ(a){
    const n = this.n;
    const R = 2*n;
    const mask = (1<<a);

    // Case I: find p in stabilizer rows with x_{p,a}=1
    let p = -1;
    for (let i=n;i<2*n;i++){
      if (this.x[i] & mask){ p = i; break; }
    }
    if (p !== -1){
      // random outcome
      for (let i=0;i<2*n;i++){
        if (i!==p && (this.x[i] & mask)){
          this.rowsum(i,p);
        }
      }
      // copy row p to row p-n
      this.x[p-n] = this.x[p];
      this.z[p-n] = this.z[p];
      this.r[p-n] = this.r[p];

      // set stabilizer row p to Z_a with random phase
      this.x[p] = 0;
      this.z[p] = mask;
      this.r[p] = (Math.random()<0.5) ? 0 : 1;
      return this.r[p];
    }

    // Case II: deterministic
    this.x[R] = 0; this.z[R] = 0; this.r[R] = 0;
    for (let i=0;i<n;i++){
      if (this.x[i] & mask){
        this.rowsum(R, i+n);
      }
    }
    return this.r[R];
  }

  // Peek P(1) for Z measurement without collapsing.
  peekProb1Z(a){
    const n = this.n;
    const R = 2*n;
    const mask = (1<<a);
    // if exists stabilizer row with X on a => random
    for (let i=n;i<2*n;i++){
      if (this.x[i] & mask) return 0.5;
    }
    // deterministic: compute outcome via scratch
    const xSave = this.x[R], zSave = this.z[R], rSave = this.r[R];
    this.x[R] = 0; this.z[R] = 0; this.r[R] = 0;
    for (let i=0;i<n;i++){
      if (this.x[i] & mask) this.rowsum(R, i+n);
    }
    const out = this.r[R];
    this.x[R]=xSave; this.z[R]=zSave; this.r[R]=rSave;
    return out ? 1.0 : 0.0;
  }

  // Expectation for single-qubit Pauli using clone+basis change.
  expect1Q(q, pauli){
    if (pauli==="Z"){
      const p1 = this.peekProb1Z(q);
      return 1 - 2*p1;
    }
    if (pauli==="X"){
      const t = this.clone();
      t.hGate(q);
      const p1 = t.peekProb1Z(q);
      return 1 - 2*p1;
    }
    if (pauli==="Y"){
      const t = this.clone();
      t.sdgGate(q);
      t.hGate(q);
      const p1 = t.peekProb1Z(q);
      return 1 - 2*p1;
    }
    return 0;
  }
}

// ---------- Pulse compiler helpers ----------
function gate_Rx(tab,q,angleRad, log){
  // compile to nearest Clifford among {0, ±π/2, π}
  const a = normAngle(angleRad);
  const opts = [
    {a:0, f:()=>{}},
    {a:Math.PI/2, f:()=>{ tab.hGate(q); tab.sGate(q); tab.hGate(q); }},
    {a:-Math.PI/2, f:()=>{ tab.hGate(q); tab.sdgGate(q); tab.hGate(q); }},
    {a:Math.PI, f:()=>{ tab.xGate(q); }},
    {a:-Math.PI, f:()=>{ tab.xGate(q); }},
  ];
  const best = closestAngle(a, opts.map(o=>o.a));
  const chosen = opts.find(o=>almostEqAngle(o.a, best));
  if (!almostEqAngle(a,best)) log(`RAMAN Rx(${fmt(a,3)}) rounded to Rx(${fmt(best,3)}) (Clifford-calibrated)`);
  chosen.f();
  return best;
}
function gate_Ry(tab,q,angleRad, log){
  const a = normAngle(angleRad);
  const opts = [
    {a:0, f:()=>{}},
    {a:Math.PI/2, f:()=>{ tab.zGate(q); tab.hGate(q); }},     // Ry(+π/2)=Z·H
    {a:-Math.PI/2, f:()=>{ tab.hGate(q); tab.zGate(q); }},    // Ry(-π/2)=H·Z
    {a:Math.PI, f:()=>{ tab.yGate(q); }},
    {a:-Math.PI, f:()=>{ tab.yGate(q); }},
  ];
  const best = closestAngle(a, opts.map(o=>o.a));
  const chosen = opts.find(o=>almostEqAngle(o.a,best));
  if (!almostEqAngle(a,best)) log(`RAMAN Ry(${fmt(a,3)}) rounded to Ry(${fmt(best,3)})`);
  chosen.f();
  return best;
}
function gate_Rz(tab,q,angleRad, log){
  const a = normAngle(angleRad);
  const opts = [
    {a:0, f:()=>{}},
    {a:Math.PI/2, f:()=>{ tab.sGate(q); }},
    {a:-Math.PI/2, f:()=>{ tab.sdgGate(q); }},
    {a:Math.PI, f:()=>{ tab.zGate(q); }},
    {a:-Math.PI, f:()=>{ tab.zGate(q); }},
  ];
  const best = closestAngle(a, opts.map(o=>o.a));
  const chosen = opts.find(o=>almostEqAngle(o.a,best));
  if (!almostEqAngle(a,best)) log(`VZ/Rz(${fmt(a,3)}) rounded to Rz(${fmt(best,3)})`);
  chosen.f();
  return best;
}
function gate_MS(tab, a, b, thetaRad, log){
  // Clifford-calibrated to maximally entangling Rxx(±π/2)
  // We compile any |theta| closer to π/2; sign chooses ±.
  const t = normAngle(thetaRad);
  // choose +pi/2 or -pi/2 as closest
  const target = (Math.abs(normAngle(t - Math.PI/2)) <= Math.abs(normAngle(t + Math.PI/2))) ? (Math.PI/2) : (-Math.PI/2);
  if (!almostEqAngle(t,target)) log(`MS theta=${fmt(t,3)} rounded to Rxx(${fmt(target,3)}) (max entangling Clifford)`);
  // We implement Rxx(+π/2) using decomposition:
  // H(a) H(b) S(a) S(b) H(b) CNOT(a,b) H(a)
  // For negative, conjugate by Z on one qubit before & after (approx) – here we just flip sign by Sdg/S swaps.
  if (target > 0){
    tab.hGate(a); tab.hGate(b);
    tab.sGate(a); tab.sGate(b);
    tab.hGate(b);
    tab.cnot(a,b);
    tab.hGate(a);
  } else {
    // Rxx(-π/2) = (Rxx(π/2))†. Implement inverse: H(a) CNOT(a,b) H(b) S†(a) S†(b) H(a) H(b)
    tab.hGate(a);
    tab.cnot(a,b);
    tab.hGate(b);
    tab.sdgGate(a); tab.sdgGate(b);
    tab.hGate(a); tab.hGate(b);
  }
  return target;
}
function closestAngle(a, opts){
  let best = opts[0], bestD = Math.abs(normAngle(a-opts[0]));
  for (const o of opts){
    const d = Math.abs(normAngle(a-o));
    if (d < bestD){ best=o; bestD=d; }
  }
  return best;
}
function almostEqAngle(a,b){ return Math.abs(normAngle(a-b)) < 1e-6; }
function normAngle(a){
  // map to [-pi,pi]
  let x = a % TAU;
  if (x > Math.PI) x -= TAU;
  if (x < -Math.PI) x += TAU;
  return x;
}

// ---------- Error model ----------
function applyDepolarizing1Q(tab, q, p){
  if (p<=0) return;
  if (Math.random() >= p) return;
  const r = Math.floor(Math.random()*3);
  if (r===0) tab.xGate(q);
  else if (r===1) tab.yGate(q);
  else tab.zGate(q);
}
function applyDepolarizing2Q(tab, a, b, p){
  if (p<=0) return;
  if (Math.random() >= p) return;
  // choose one of 15 non-identity Pauli products on (a,b)
  const paulis = ["I","X","Y","Z"];
  let pA="I", pB="I";
  while(pA==="I" && pB==="I"){
    pA = choice(paulis);
    pB = choice(paulis);
  }
  applyPauli(tab, a, pA);
  applyPauli(tab, b, pB);
}
function applyPauli(tab, q, p){
  if (p==="I") return;
  if (p==="X") tab.xGate(q);
  else if (p==="Y") tab.yGate(q);
  else if (p==="Z") tab.zGate(q);
}

// Dephasing from T2 over duration t (seconds): phase-flip prob (1-exp(-t/T2))/2
function applyT2Dephasing(tab, qubits, tSec, T2){
  if (!(T2>0) || tSec<=0) return;
  const p = (1 - Math.exp(-tSec / T2)) / 2;
  if (p<=0) return;
  for (const q of qubits){
    if (Math.random() < p) tab.zGate(q);
  }
}

// ---------- Simple lab physics model ----------
const PHYS = {
  kB: 1.380649e-23,
  hbar: 1.054571817e-34,
  eps0: 8.8541878128e-12,
  e: 1.602176634e-19,
  amu: 1.66053906660e-27,
  mYb171: 171 * 1.66053906660e-27
};

function dopplerLimitTemp_Yb(){
  // T_D = ħΓ / (2kB), Γ ≈ 2π·19.6 MHz for 369.53 nm transition.
  const Gamma = TAU * 19.6e6;
  return PHYS.hbar * Gamma / (2 * PHYS.kB);
}
function nbarFromTemp(T, omega){
  // n̄ ≈ kB T / (ħ ω) for kBT >> ħω
  return (PHYS.kB * T) / (PHYS.hbar * omega);
}
function trapLengthScale(omegaZ){
  // l = (k_e e^2 / (m ω^2))^(1/3)
  const ke = 1/(4*Math.PI*PHYS.eps0);
  const num = ke * (PHYS.e*PHYS.e);
  const den = PHYS.mYb171 * (omegaZ*omegaZ);
  return Math.cbrt(num/den);
}
// Minimize 1D chain potential U = 0.5 Σ u_i^2 + Σ_{i<j} 1/|u_i-u_j|
// in dimensionless units; then z = u * l.
function solveIonChainPositions(N, omegaZ){
  if (N<=0) return [];
  if (N===1) return [0];
  let u = [];
  const spacing = 1.5;
  for (let i=0;i<N;i++){
    u.push((i-(N-1)/2)*spacing);
  }
  const steps = 500;
  let alpha = 0.03;
  for (let it=0;it<steps;it++){
    const grad = new Array(N).fill(0);
    for (let i=0;i<N;i++){
      // harmonic term
      grad[i] += u[i];
      // coulomb
      for (let j=0;j<N;j++){
        if (i===j) continue;
        const d = u[i]-u[j];
        const ad = Math.abs(d);
        const denom = (ad*ad*ad) + 1e-9;
        grad[i] -= d/denom;
      }
    }
    // update
    let maxStep=0;
    for (let i=0;i<N;i++){
      const du = -alpha*grad[i];
      u[i] += du;
      maxStep = Math.max(maxStep, Math.abs(du));
    }
    if (maxStep < 1e-6) break;
    // mild anneal
    alpha *= 0.997;
  }
  // scale to meters
  const l = trapLengthScale(omegaZ);
  return u.map(x=>x*l);
}

// ---------- Pulse program parsing ----------
function parseProgram(text){
  const lines = text.split(/\r?\n/);
  const ops = [];
  let tCursor = 0; // seconds
  for (let ln=0; ln<lines.length; ln++){
    let line = lines[ln].trim();
    if (!line || line.startsWith("#")) continue;
    // allow inline comments
    const hash = line.indexOf("#");
    if (hash >= 0) line = line.slice(0,hash).trim();
    if (!line) continue;
    const parts = line.split(/\s+/);
    const cmd = parts[0].toUpperCase();
    const kv = {};
    // parse key=val tokens
    for (let i=1;i<parts.length;i++){
      const tok = parts[i];
      const eq = tok.indexOf("=");
      if (eq<0) continue;
      const k = tok.slice(0,eq).toLowerCase();
      const v = tok.slice(eq+1);
      kv[k] = v;
    }
    // helper parse time to seconds
    const parseTime = (s, dflt=0) => {
      if (s===undefined) return dflt;
      const m = String(s).match(/^([0-9]*\.?[0-9]+)(ns|us|µs|ms|s)$/i);
      if (!m) return parseFloat(s)||dflt;
      const val = parseFloat(m[1]);
      const unit = m[2].toLowerCase().replace("µ","u");
      if (unit==="ns") return val*1e-9;
      if (unit==="us") return val*1e-6;
      if (unit==="ms") return val*1e-3;
      return val;
    };
    const parseAngle = (s, dflt=0) => {
      if (s===undefined) return dflt;
      const str = String(s).toLowerCase();
      // allow pi fractions like pi/2, -pi/4
      if (str.includes("pi")){
        // crude eval: replace pi with Math.PI and allow / and *
        try{
          const expr = str.replace(/pi/g, "Math.PI");
          // eslint-disable-next-line no-new-func
          return Function("return ("+expr+")")();
        }catch(e){
          return dflt;
        }
      }
      return parseFloat(s);
    };

    // build op object
    if (cmd==="PUMP_DOWN"){
      const dur = parseTime(kv.t || kv.time || "60s", 60);
      ops.push({cmd, t0:tCursor, dt:dur, kv});
      tCursor += dur;
      continue;
    }
    if (cmd==="OVEN"){
      const dur = parseTime(kv.t || kv.time || "30s", 30);
      const tempC = parseFloat(kv.temp||kv.c||kv.set||"450");
      ops.push({cmd, t0:tCursor, dt:dur, kv:{tempC}});
      tCursor += dur;
      continue;
    }
    if (cmd==="PI"){ // photoionization load
      const dur = parseTime(kv.t||"3s", 3);
      const ions = parseInt(kv.ions||kv.n||"2",10);
      ops.push({cmd, t0:tCursor, dt:dur, kv:{ions}});
      tCursor += dur;
      continue;
    }
    if (cmd==="DOPPLER"){
      const dur = parseTime(kv.t||"2ms", 0.002);
      const det = kv.det || kv.delta || "-10MHz";
      ops.push({cmd, t0:tCursor, dt:dur, kv:{det}});
      tCursor += dur;
      continue;
    }
    if (cmd==="SIDEBAND"){
      const dur = parseTime(kv.t||"5ms", 0.005);
      ops.push({cmd, t0:tCursor, dt:dur, kv:{}});
      tCursor += dur;
      continue;
    }
    if (cmd==="OPTPUMP"){
      const dur = parseTime(kv.t||"20us", 20e-6);
      ops.push({cmd, t0:tCursor, dt:dur, kv:{}});
      tCursor += dur;
      continue;
    }
    if (cmd==="RAMAN"){
      const dur = parseTime(kv.t||"5us", 5e-6);
      const q = parseInt(kv.q||kv.ion||kv.i||"0",10);
      const axis = (kv.axis||"X").toUpperCase();
      const ang = parseAngle(kv.angle||kv.theta||"pi/2", Math.PI/2);
      ops.push({cmd, t0:tCursor, dt:dur, kv:{q,axis,ang}});
      tCursor += dur;
      continue;
    }
    if (cmd==="MS"){
      const dur = parseTime(kv.t||"180us", 180e-6);
      const q0 = parseInt(kv.q0||kv.a||kv.i||"0",10);
      const q1 = parseInt(kv.q1||kv.b||kv.j||"1",10);
      const theta = parseAngle(kv.theta||kv.angle||"pi/2", Math.PI/2);
      const delta = kv.delta||kv.det||"10kHz";
      ops.push({cmd, t0:tCursor, dt:dur, kv:{q0,q1,theta,delta}});
      tCursor += dur;
      continue;
    }
    if (cmd==="VZ"){
      const dur = parseTime(kv.t||"0us", 0);
      const q = parseInt(kv.q||"0",10);
      const ang = parseAngle(kv.angle||kv.theta||"pi/2", Math.PI/2);
      ops.push({cmd, t0:tCursor, dt:dur, kv:{q,ang}});
      tCursor += dur;
      continue;
    }
    if (cmd==="MEASURE"){
      const dur = parseTime(kv.t||"300us", 300e-6);
      ops.push({cmd, t0:tCursor, dt:dur, kv:{}});
      tCursor += dur;
      continue;
    }

    // convenient logical ops (compile to pulses)
    if (cmd==="H" || cmd==="S" || cmd==="SDG" || cmd==="X" || cmd==="Y" || cmd==="Z"){
      const q = parseInt(parts[1]||"0",10);
      ops.push({cmd, t0:tCursor, dt:0, kv:{q}});
      continue;
    }
    if (cmd==="CX" || cmd==="CNOT"){
      const c = parseInt(parts[1]||"0",10);
      const t = parseInt(parts[2]||"1",10);
      ops.push({cmd:"CX", t0:tCursor, dt:0, kv:{c,t}});
      continue;
    }
    if (cmd==="CZ"){
      const a = parseInt(parts[1]||"0",10);
      const b = parseInt(parts[2]||"1",10);
      ops.push({cmd:"CZ", t0:tCursor, dt:0, kv:{a,b}});
      continue;
    }
    throw new Error(`Line ${ln+1}: Unknown command "${cmd}"`);
  }
  return ops;
}

// ---------- Templates ----------
function templateBell(){
  return `# Bell state in 171Yb+ (pulse-level)
# End-to-end: pumpdown -> oven -> photoionization -> cooling -> optical pump -> MS -> phase corr -> measure
PUMP_DOWN t=40s
OVEN temp=450 t=20s
PI ions=2 t=2s
DOPPLER t=2ms det=-10MHz
SIDEBAND t=5ms
OPTPUMP t=20us
# Mølmer–Sørensen entangling gate (max entangling); produces (|00> - i|11>)/sqrt(2)
MS q0=0 q1=1 theta=pi/2 delta=10kHz t=180us
# Virtual Z: apply S on one qubit to remove the -i phase on |11> (virtual frame update)
VZ q=0 angle=pi/2
MEASURE t=300us`;
}
function templateGHZ(n){
  // build chain entanglement with MS(0,k) then local phase
  let s = `# GHZ on ${n} ions (Clifford compiled)\n`;
  s += `OPTPUMP t=20us\n`;
  // Prepare |+000..> via Ry(pi/2) on qubit 0 (equiv to H up to phase)
  s += `RAMAN q=0 axis=Y angle=pi/2 t=5us\n`;
  for (let k=1;k<n;k++){
    s += `MS q0=0 q1=${k} theta=pi/2 delta=10kHz t=180us\n`;
  }
  // phase corr
  s += `VZ q=0 angle=pi/2\nMEASURE t=300us`;
  return s;
}
function templateBV(n){
  // Use last qubit as ancilla; secret string hardcoded
  const data = n-1;
  const secret = [];
  for (let i=0;i<data;i++) secret.push(Math.random()<0.5?0:1);
  let s = `# Bernstein–Vazirani (Clifford), n=${n} (data=${data}, ancilla=${n-1})\n`;
  s += `# secret a = ${secret.join("")}\n`;
  s += `OPTPUMP t=20us\n`;
  // Prepare ancilla in |1> then H => |->; prepare all data in |+>
  s += `RAMAN q=${n-1} axis=X angle=pi t=5us\n`; // X pi
  s += `H ${n-1}\n`;
  for (let i=0;i<data;i++){
    s += `H ${i}\n`;
  }
  // Oracle: for each ai=1 do CNOT i -> ancilla
  for (let i=0;i<data;i++){
    if (secret[i]===1) s += `CX ${i} ${n-1}\n`;
  }
  // Hadamards back on data, measure data
  for (let i=0;i<data;i++){
    s += `H ${i}\n`;
  }
  s += `MEASURE t=300us`;
  return s;
}
function templateRandCliff(n){
  let s = `# Random Clifford benchmark (n=${n})\nOPTPUMP t=20us\n`;
  const gates = ["H","S","SDG","X","Z","Y"];
  for (let k=0;k<40;k++){
    const g = choice(gates);
    const q = Math.floor(Math.random()*n);
    if (g==="H"||g==="S"||g==="SDG"||g==="X"||g==="Y"||g==="Z"){
      s += `${g} ${q}\n`;
    }
    if (Math.random()<0.25 && n>=2){
      const a = Math.floor(Math.random()*n);
      let b = Math.floor(Math.random()*n);
      if (b===a) b = (b+1)%n;
      s += `MS q0=${a} q1=${b} theta=pi/2 t=180us\n`;
    }
  }
  s += `MEASURE t=300us`;
  return s;
}

// ---------- Experiment runner ----------
function runShots(programOps, cfg, log){
  const n = cfg.n;
  const shots = cfg.shots;
  const dist = new Map();
  const brightHist = []; // record total counts per ion? We'll accumulate global histogram for one ion (ion0) for display
  const darkHist = [];
  const pulseRects = []; // for drawing
  const setupCmds = new Set(["PUMP_DOWN","OVEN","PI"]);
  const perShotOps = programOps.filter(op => !setupCmds.has(op.cmd.toUpperCase()));

  let totalTime = 0;
  for (const op of perShotOps){
    totalTime += op.dt;
  }

  // Precompute timeline rectangles for display
  for (const op of programOps){
    const tag = op.cmd;
    pulseRects.push({
      t0: op.t0,
      t1: op.t0 + op.dt,
      tag,
      detail: JSON.stringify(op.kv)
    });
  }

  // Run shots
  const detT = cfg.detTimeUs * 1e-6;
  const brightMean = cfg.brightMean;
  const darkMean = cfg.darkMean;
  const thresh = cfg.thresh;

  // Ion motion initial (from lab)
  // We'll update per-shot locally (not permanently) to mimic re-cooling each shot in program.
  const T_D = dopplerLimitTemp_Yb();
  const omegaZ = TAU * (cfg.wzMHz * 1e6);
  const nbarDoppler = nbarFromTemp(T_D, omegaZ);
  const nbarSB = 0.05;

  // Vacuum collision model: p_coll = 1-exp(-t_total/tau); tau scales ~1/P
  const P = cfg.pressureTorr;
  const tauCollAt1e11 = 3600*6; // 6 hours at 1e-11 Torr (toy)
  const tauColl = tauCollAt1e11 * (1e-11 / Math.max(1e-13, P));

  const activeQ = [...Array(n).keys()];

  for (let s=0;s<shots;s++){
    // collision?
    if (Math.random() < (1 - Math.exp(-totalTime / tauColl))){
      // collision spoils shot: random outcome
      const bits = randomBitstring(n);
      dist.set(bits, (dist.get(bits)||0)+1);
      continue;
    }

    let nbar = cfg.nbarInit; // start from lab cooled state (or will be overwritten by program commands)
    const tab = new Stabilizer(n);

    // Execute program
    for (const op of perShotOps){
      const cmd = op.cmd.toUpperCase();
      const dt = op.dt;

      // continuous dephasing during any time dt (applies to all qubits)
      applyT2Dephasing(tab, activeQ, dt, cfg.T2);

      // motional heating during dt
      nbar += cfg.heatingRate * dt; // quanta/sec * sec

      if (cmd==="PUMP_DOWN" || cmd==="OVEN" || cmd==="PI"){
        // lab-only: doesn't affect qubits per shot
        continue;
      }
      if (cmd==="DOPPLER"){
        // approach Doppler limit
        const tau = 0.0006; // 0.6 ms time constant (toy)
        const t = dt;
        nbar = nbarDoppler + (nbar - nbarDoppler)*Math.exp(-t/tau);
        continue;
      }
      if (cmd==="SIDEBAND"){
        const tau = 0.002; // 2 ms
        const t = dt;
        nbar = nbarSB + (nbar - nbarSB)*Math.exp(-t/tau);
        continue;
      }
      if (cmd==="OPTPUMP"){
        // reset internal state to |0...0> (perfect in model; SPAM handled at readout)
        tab.resetToZero();
        // optical pumping also cools slightly (toy)
        nbar = Math.max(nbarSB, nbar*0.95);
        continue;
      }
      if (cmd==="H"){ tab.hGate(op.kv.q); continue; }
      if (cmd==="S"){ tab.sGate(op.kv.q); continue; }
      if (cmd==="SDG"){ tab.sdgGate(op.kv.q); continue; }
      if (cmd==="X"){ tab.xGate(op.kv.q); continue; }
      if (cmd==="Y"){ tab.yGate(op.kv.q); continue; }
      if (cmd==="Z"){ tab.zGate(op.kv.q); continue; }
      if (cmd==="CX"){
        tab.cnot(op.kv.c, op.kv.t);
        continue;
      }
      if (cmd==="CZ"){
        const a=op.kv.a, b=op.kv.b;
        tab.hGate(b); tab.cnot(a,b); tab.hGate(b);
        continue;
      }

      if (cmd==="RAMAN"){
        const {q,axis,ang} = op.kv;
        // Apply ideal (rounded) Clifford
        if (axis==="X") gate_Rx(tab,q,ang, ()=>{});
        else if (axis==="Y") gate_Ry(tab,q,ang, ()=>{});
        else gate_Rz(tab,q,ang, ()=>{});
        // Apply stochastic gate error
        applyDepolarizing1Q(tab,q,cfg.p1);
        continue;
      }
      if (cmd==="VZ"){
        gate_Rz(tab, op.kv.q, op.kv.ang, ()=>{});
        // virtual Z is software phase update; we treat as zero-time perfect gate by default
        continue;
      }
      if (cmd==="MS"){
        const {q0,q1,theta} = op.kv;
        gate_MS(tab,q0,q1,theta, ()=>{});
        // Two-qubit gate depolarizing + motional error term
        const pMot = clamp(cfg.msMotionCoeff * Math.max(0, nbar), 0, 0.25);
        applyDepolarizing2Q(tab,q0,q1, clamp(cfg.p2 + pMot, 0, 0.5));
        continue;
      }
      if (cmd==="MEASURE"){
        // perform measurement at end; break after measurement
        break;
      }
    }

    // Readout: measure all ions; also simulate photon counts for ion0 histogram
    const idealBits = [];
    const measCounts = [];
    for (let q=0;q<n;q++){
      const bit = tab.measureZ(q); // collapses
      idealBits.push(bit);
      const lam = (bit===1) ? brightMean : darkMean;
      const c = poisson(lam);
      measCounts.push(c);
    }
    // threshold discriminates each ion
    const observed = idealBits.map((b,i)=>{
      const bHat = (measCounts[i] >= thresh) ? 1 : 0;
      return bHat;
    });
    const bits = observed.slice().reverse().join(""); // MSB left for display
    dist.set(bits, (dist.get(bits)||0)+1);
    // store per-ion0 hist
    if (idealBits[0]===1) brightHist.push(measCounts[0]); else darkHist.push(measCounts[0]);
  }

  return {dist, pulseRects, brightHist, darkHist};
}

function randomBitstring(n){
  let s="";
  for (let i=0;i<n;i++) s = (Math.random()<0.5?"0":"1")+s;
  return s;
}

// ---------- UI wiring ----------
const el = (id)=>document.getElementById(id);
const logEl = el("log");
function log(msg){
  const t = new Date().toLocaleTimeString();
  logEl.textContent += `[${t}] ${msg}\n`;
  logEl.scrollTop = logEl.scrollHeight;
}

const ui = {
  dotReady: el("dotReady"),
  readyTxt: el("readyTxt"),
  kvPressure: el("kvPressure"),
  kvOven: el("kvOven"),
  kvRF: el("kvRF"),
  kvWz: el("kvWz"),
  kvIons: el("kvIons"),
  kvNbar: el("kvNbar"),
  selBaseP: el("selBaseP"),
  rngPump: el("rngPump"),
  txtPump: el("txtPump"),
  rngOven: el("rngOven"),
  txtOvenSet: el("txtOvenSet"),
  selPI: el("selPI"),
  btnPump: el("btnPump"),
  btnBake: el("btnBake"),
  btnOven: el("btnOven"),
  btnLoad: el("btnLoad"),
  btnCool: el("btnCool"),
  numQ: el("numQ"),
  numRFf: el("numRFf"),
  numRFv: el("numRFv"),
  numWz: el("numWz"),
  numWr: el("numWr"),
  numB: el("numB"),
  numHeat: el("numHeat"),
  numT2: el("numT2"),
  numP1: el("numP1"),
  numP2: el("numP2"),
  selTemplate: el("selTemplate"),
  txtProgram: el("txtProgram"),
  numShots: el("numShots"),
  btnCompile: el("btnCompile"),
  btnRun: el("btnRun"),
  btnReset: el("btnReset"),
  cvEnv: el("cvEnv"),
  cvIons: el("cvIons"),
  cvPulse: el("cvPulse"),
  cvReadout: el("cvReadout"),
  tblOut: el("tblOut"),
  numDetT: el("numDetT"),
  numBright: el("numBright"),
  numDark: el("numDark"),
  numThresh: el("numThresh"),
};

// ---------- Lab state machine (continuous visuals) ----------
const lab = {
  baseP: 1e-11,
  pumpSpeed: 1.2,
  pumping: false,
  baking: false,
  bakeBoost: 1.0,
  pressure: 2e-8,
  ovenSetC: 450,
  ovenC: 25,
  ovenOn: false,
  PI: false,
  Ntarget: 2,
  Nloaded: 0,
  loaded: false,
  dopplerDone: false,
  sidebandDone: false,
  nbar: 25,
  // trap
  rfMHz: 37,
  rfVpp: 200,
  wzMHz: 0.20,
  wrMHz: 1.0,
  Bgauss: 6,
  // heating and T2 are in cfg UI
  t: 0,
  ionPositions: [],
  envTrace: [], // time series
};

function resetLab(){
  lab.baseP = parseFloat(ui.selBaseP.value);
  lab.pumpSpeed = parseFloat(ui.rngPump.value);
  lab.pumping = false;
  lab.baking = false;
  lab.bakeBoost = 1.0;
  lab.pressure = 2e-8;
  lab.ovenSetC = parseFloat(ui.rngOven.value);
  lab.ovenC = 25;
  lab.ovenOn = false;
  lab.PI = (ui.selPI.value==="on");
  lab.Ntarget = clamp(parseInt(ui.numQ.value,10)||2,1,16);
  lab.Nloaded = 0;
  lab.loaded = false;
  lab.dopplerDone = false;
  lab.sidebandDone = false;
  lab.nbar = 25;
  lab.rfMHz = parseFloat(ui.numRFf.value);
  lab.rfVpp = parseFloat(ui.numRFv.value);
  lab.wzMHz = parseFloat(ui.numWz.value);
  lab.wrMHz = parseFloat(ui.numWr.value);
  lab.Bgauss = parseFloat(ui.numB.value);
  lab.t = 0;
  lab.envTrace = [];
  updateIonPositions();
  logEl.textContent = "";
  log("Lab reset.");
}

function updateIonPositions(){
  const N = lab.Ntarget;
  const omegaZ = TAU * (lab.wzMHz * 1e6);
  const z = solveIonChainPositions(N, omegaZ);
  lab.ionPositions = z;
}

function isLabReady(){
  return lab.pressure <= Math.max(3*lab.baseP, 3e-11) && lab.ovenC>=lab.ovenSetC-20 && lab.loaded && lab.sidebandDone;
}

function updateSummary(){
  ui.txtPump.textContent = fmt(lab.pumpSpeed,1)+"×";
  ui.txtOvenSet.textContent = Math.round(lab.ovenSetC)+"°C";
  ui.kvPressure.textContent = fmt(lab.pressure,2)+" Torr";
  ui.kvOven.textContent = Math.round(lab.ovenC)+" °C";
  ui.kvRF.textContent = `${fmt(lab.rfMHz,1)} MHz @ ${Math.round(lab.rfVpp)} Vpp`;
  ui.kvWz.textContent = `${fmt(lab.wzMHz,2)} MHz`;
  ui.kvIons.textContent = `${lab.Nloaded}/${lab.Ntarget}`;
  ui.kvNbar.textContent = fmt(lab.nbar,2);
  const ready = isLabReady();
  ui.dotReady.style.background = ready ? "var(--ok)" : (lab.loaded ? "var(--warn)" : "var(--bad)");
  ui.readyTxt.textContent = ready ? "Ready for shots" : (lab.loaded ? "Needs cooling/UHV" : "Not ready");
}

function stepLab(dt){
  lab.t += dt;

  // pumpdown: exponential approach to base pressure
  if (lab.pumping){
    const tau = 45 / lab.pumpSpeed; // seconds
    const target = lab.baseP * (lab.baking ? 0.6 : 1.0);
    lab.pressure = target + (lab.pressure - target) * Math.exp(-dt/tau);
  } else {
    // slow rise if pump off (outgassing)
    lab.pressure *= Math.exp(dt / 6000);
    lab.pressure = Math.min(lab.pressure, 5e-7);
  }

  // bakeout reduces outgassing effectively
  if (lab.baking){
    lab.bakeBoost = Math.max(0.6, lab.bakeBoost * Math.exp(-dt/800));
  }

  // oven thermal dynamics
  const tauOven = 18; // seconds
  const targetT = lab.ovenOn ? lab.ovenSetC : 25;
  lab.ovenC = targetT + (lab.ovenC - targetT) * Math.exp(-dt/tauOven);

  // loading probability when PI and oven hot and trap on
  lab.PI = (ui.selPI.value==="on");
  if (lab.PI && lab.ovenC > lab.ovenSetC-10 && lab.pumping && lab.pressure < 5e-10){
    // simplistic flux model: increases with temperature and decreases with pressure
    const tempFactor = Math.exp((lab.ovenC-350)/80);
    const pressFactor = clamp(5e-10 / lab.pressure, 0.1, 30);
    const rate = 0.15 * tempFactor * (pressFactor/5); // ions/sec
    const p = 1 - Math.exp(-rate*dt);
    if (Math.random() < p && lab.Nloaded < lab.Ntarget){
      lab.Nloaded++;
      log(`Ion loaded: ${lab.Nloaded}/${lab.Ntarget}`);
      if (lab.Nloaded === lab.Ntarget){
        lab.loaded = true;
        log("Target ion chain loaded. Turn off PI to avoid overloading.");
      }
      updateIonPositions();
    }
  }

  // simple cooling status
  // motional heating in the idle lab
  const heatRate = parseFloat(ui.numHeat.value)||0;
  lab.nbar += heatRate * dt; // quanta/s * s
  lab.nbar = Math.min(lab.nbar, 2000);

  // store trace every ~0.2s
  if (lab.envTrace.length===0 || (lab.t - lab.envTrace[lab.envTrace.length-1].t) > 0.2){
    lab.envTrace.push({t:lab.t, p:lab.pressure, oven:lab.ovenC});
    if (lab.envTrace.length>500) lab.envTrace.shift();
  }

  updateSummary();
}

ui.btnPump.addEventListener("click", ()=>{
  lab.pumping = !lab.pumping;
  log(lab.pumping ? "Pumps ON (pumpdown started)." : "Pumps OFF.");
});
ui.btnBake.addEventListener("click", ()=>{
  lab.baking = !lab.baking;
  log(lab.baking ? "Bakeout ON (outgassing reduced over time)." : "Bakeout OFF.");
});
ui.btnOven.addEventListener("click", ()=>{
  lab.ovenOn = !lab.ovenOn;
  log(lab.ovenOn ? `Oven ON → ${Math.round(lab.ovenSetC)}°C` : "Oven OFF → room temperature");
});
ui.btnLoad.addEventListener("click", ()=>{
  if (!lab.PI){
    log("Turn PI ON (399+369) first to load ions.");
    return;
  }
  log("Loading is stochastic; wait for bright spots (simulated).");
});
ui.btnCool.addEventListener("click", ()=>{
  // Do Doppler then sideband instantly for lab state (UI step)
  const T_D = dopplerLimitTemp_Yb();
  const omegaZ = TAU*(lab.wzMHz*1e6);
  const nD = nbarFromTemp(T_D, omegaZ);
  lab.nbar = nD;
  lab.dopplerDone = true;
  // sideband to ground-ish
  lab.nbar = 0.05;
  lab.sidebandDone = true;
  log(`Cooling complete: Doppler limit T≈${fmt(T_D*1e3,3)} mK; n̄→${fmt(lab.nbar,2)}.`);
});

ui.rngPump.addEventListener("input", ()=>{ lab.pumpSpeed = parseFloat(ui.rngPump.value); updateSummary(); });
ui.rngOven.addEventListener("input", ()=>{ lab.ovenSetC = parseFloat(ui.rngOven.value); updateSummary(); });
ui.selBaseP.addEventListener("change", ()=>{ lab.baseP = parseFloat(ui.selBaseP.value); updateSummary(); });
ui.numQ.addEventListener("change", ()=>{
  lab.Ntarget = clamp(parseInt(ui.numQ.value,10)||2,1,16);
  if (lab.Nloaded > lab.Ntarget) lab.Nloaded = lab.Ntarget;
  lab.loaded = (lab.Nloaded === lab.Ntarget);
  updateIonPositions();
  updateTemplate();
});
ui.numWz.addEventListener("change", ()=>{ lab.wzMHz = parseFloat(ui.numWz.value); updateIonPositions(); });
ui.numRFf.addEventListener("change", ()=>{ lab.rfMHz = parseFloat(ui.numRFf.value); });
ui.numRFv.addEventListener("change", ()=>{ lab.rfVpp = parseFloat(ui.numRFv.value); });
ui.numWr.addEventListener("change", ()=>{ lab.wrMHz = parseFloat(ui.numWr.value); });
ui.numB.addEventListener("change", ()=>{ lab.Bgauss = parseFloat(ui.numB.value); });

function updateTemplate(){
  const n = clamp(parseInt(ui.numQ.value,10)||2,1,16);
  const t = ui.selTemplate.value;
  if (t==="bell") ui.txtProgram.value = templateBell();
  else if (t==="ghz") ui.txtProgram.value = templateGHZ(n);
  else if (t==="bv") ui.txtProgram.value = templateBV(Math.max(2,n));
  else if (t==="randcliff") ui.txtProgram.value = templateRandCliff(n);
  else if (t==="blank") ui.txtProgram.value = `# Write your pulse program here.\nOPTPUMP t=20us\nMEASURE t=300us`;
}
ui.selTemplate.addEventListener("change", updateTemplate);

// Compile/validate
ui.btnCompile.addEventListener("click", ()=>{
  try{
    const ops = parseProgram(ui.txtProgram.value);
    log(`Program validated: ${ops.length} ops parsed.`);
    // warn if missing measure
    const hasMeas = ops.some(o=>o.cmd.toUpperCase()==="MEASURE");
    if (!hasMeas) log("Warning: no MEASURE step found; simulation will measure at end anyway.");
    drawPulseTimeline(ops);
  }catch(e){
    log(`ERROR: ${e.message}`);
  }
});

// Run
ui.btnRun.addEventListener("click", ()=>{
  try{
    const ops = parseProgram(ui.txtProgram.value);
    const n = clamp(parseInt(ui.numQ.value,10)||2,1,16);
    const shots = clamp(parseInt(ui.numShots.value,10)||1000,1,20000);
    const cfg = {
      n,
      shots,
      pressureTorr: lab.pressure,
      wzMHz: parseFloat(ui.numWz.value),
      T2: Math.max(1e-6, parseFloat(ui.numT2.value)),
      heatingRate: Math.max(0, parseFloat(ui.numHeat.value)),
      p1: clamp(parseFloat(ui.numP1.value), 0, 0.2),
      p2: clamp(parseFloat(ui.numP2.value), 0, 0.8),
      msMotionCoeff: 0.002, // motional sensitivity coefficient (toy)
      nbarInit: lab.nbar,
      detTimeUs: parseFloat(ui.numDetT.value),
      brightMean: parseFloat(ui.numBright.value),
      darkMean: parseFloat(ui.numDark.value),
      thresh: parseFloat(ui.numThresh.value),
    };
    log(`Running ${shots} shots on ${n} ions...`);
    const res = runShots(ops, cfg, log);
    renderDistribution(res.dist, shots);
    drawPulseTimeline(ops);
    drawReadout(res.brightHist, res.darkHist);
    log(`Done. Unique outcomes: ${res.dist.size}.`);
  }catch(e){
    log(`ERROR: ${e.message}`);
  }
});

ui.btnReset.addEventListener("click", ()=>{
  resetLab();
});

// ---------- Rendering ----------
function clearCanvas(cv){
  const ctx = cv.getContext("2d");
  ctx.setTransform(1,0,0,1,0,0);
  ctx.clearRect(0,0,cv.width,cv.height);
  return ctx;
}

function drawEnv(){
  const cv = ui.cvEnv;
  const ctx = clearCanvas(cv);
  const W=cv.width, H=cv.height;

  // background grid
  ctx.globalAlpha = 1;
  ctx.lineWidth = 1;
  ctx.strokeStyle = "rgba(255,255,255,0.06)";
  for (let i=0;i<=10;i++){
    const x = i*W/10;
    ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,H); ctx.stroke();
  }
  for (let i=0;i<=8;i++){
    const y = i*H/8;
    ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(W,y); ctx.stroke();
  }

  // panel title text
  ctx.fillStyle = "rgba(232,238,247,0.92)";
  ctx.font = "14px "+getComputedStyle(document.body).fontFamily;
  ctx.fillText("Environment telemetry (schematic)", 16, 24);

  // plot pressure (log scale)
  const trace = lab.envTrace;
  if (trace.length < 2) return;

  const t0 = trace[0].t;
  const t1 = trace[trace.length-1].t;
  const plot = {x:50,y:60,w:W-70,h:H-90};

  // axes labels
  ctx.fillStyle = "rgba(169,183,201,0.85)";
  ctx.font = "12px "+getComputedStyle(document.body).fontFamily;
  ctx.fillText("Pressure (Torr, log)", plot.x, plot.y-14);
  ctx.fillText("Oven (°C)", plot.x + plot.w*0.62, plot.y-14);

  // y ranges
  const pMin = 1e-12, pMax = 1e-7;
  const logMin = Math.log10(pMin), logMax = Math.log10(pMax);

  function xOf(t){ return plot.x + (t - t0)/(t1 - t0) * plot.w; }
  function yOfP(p){
    const lp = Math.log10(clamp(p, pMin, pMax));
    const u = (lp - logMin)/(logMax - logMin);
    return plot.y + (1-u)*plot.h;
  }
  function yOfT(T){
    const Tmin=20, Tmax=600;
    const u=(clamp(T,Tmin,Tmax)-Tmin)/(Tmax-Tmin);
    return plot.y + (1-u)*plot.h;
  }

  // pressure line
  ctx.strokeStyle = "rgba(123,220,255,0.95)";
  ctx.lineWidth = 2;
  ctx.beginPath();
  for (let i=0;i<trace.length;i++){
    const x=xOf(trace[i].t);
    const y=yOfP(trace[i].p);
    if (i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
  }
  ctx.stroke();

  // oven line
  ctx.strokeStyle = "rgba(157,255,191,0.85)";
  ctx.lineWidth = 2;
  ctx.beginPath();
  for (let i=0;i<trace.length;i++){
    const x=xOf(trace[i].t);
    const y=yOfT(trace[i].oven);
    if (i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
  }
  ctx.stroke();

  // draw current markers
  const xNow = xOf(lab.t);
  ctx.strokeStyle = "rgba(255,255,255,0.10)";
  ctx.beginPath(); ctx.moveTo(xNow, plot.y); ctx.lineTo(xNow, plot.y+plot.h); ctx.stroke();

  // base pressure line
  const yBase = yOfP(lab.baseP);
  ctx.setLineDash([6,6]);
  ctx.strokeStyle = "rgba(255,210,123,0.55)";
  ctx.beginPath(); ctx.moveTo(plot.x, yBase); ctx.lineTo(plot.x+plot.w, yBase); ctx.stroke();
  ctx.setLineDash([]);
  ctx.fillStyle = "rgba(255,210,123,0.75)";
  ctx.fillText("base", plot.x+plot.w-30, yBase-6);

  // collision risk indicator
  const ready = isLabReady();
  const risk = clamp((lab.pressure / (10*lab.baseP)), 0, 10);
  const riskTxt = ready ? "low" : (risk<3 ? "moderate" : "high");
  ctx.fillStyle = ready ? "rgba(157,255,191,0.9)" : "rgba(255,210,123,0.85)";
  ctx.fillText(`Collision risk: ${riskTxt}`, plot.x, plot.y+plot.h+20);

  // numeric overlay
  ctx.fillStyle = "rgba(232,238,247,0.9)";
  ctx.fillText(`P=${fmt(lab.pressure,2)} Torr`, plot.x, plot.y+plot.h+40);
  ctx.fillText(`Oven=${Math.round(lab.ovenC)}°C`, plot.x+170, plot.y+plot.h+40);
  ctx.fillStyle = "rgba(169,183,201,0.85)";
  ctx.fillText(`Ωrf/2π=${fmt(lab.rfMHz,1)}MHz, ωz/2π=${fmt(lab.wzMHz,2)}MHz`, plot.x+330, plot.y+plot.h+40);
}

function drawIons(){
  const cv = ui.cvIons;
  const ctx = clearCanvas(cv);
  const W=cv.width, H=cv.height;

  // coordinate system: x axis is z (axial), y is vertical
  const margin = 70;
  const z = lab.ionPositions;
  const N = lab.Ntarget;
  const omegaZ = TAU*(lab.wzMHz*1e6);
  const l = trapLengthScale(omegaZ);
  // show +/- 6 l
  const zMin = -6*l, zMax = 6*l;
  const xOf = (zz)=> margin + (zz - zMin)/(zMax-zMin) * (W-2*margin);
  const y0 = H*0.55;

  // draw axial potential
  ctx.strokeStyle = "rgba(255,255,255,0.10)";
  ctx.lineWidth = 2;
  ctx.beginPath();
  for (let i=0;i<=400;i++){
    const zz = zMin + (zMax-zMin)*i/400;
    const U = 0.5*(zz/l)*(zz/l); // dimensionless
    const y = y0 - U*30;
    const x = xOf(zz);
    if (i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
  }
  ctx.stroke();

  // draw ions
  for (let i=0;i<N;i++){
    const x = xOf(z[i]||0);
    const y = y0;
    ctx.beginPath();
    ctx.fillStyle = "rgba(123,220,255,0.9)";
    ctx.arc(x,y, 12, 0, TAU);
    ctx.fill();
    ctx.strokeStyle = "rgba(255,255,255,0.20)";
    ctx.stroke();
    // label
    ctx.fillStyle = "rgba(11,15,20,0.9)";
    ctx.font = "bold 12px "+getComputedStyle(document.body).fontFamily;
    ctx.textAlign="center";
    ctx.fillText(String(i), x, y+4);
    ctx.textAlign="left";
  }

  // draw laser beams (schematic)
  ctx.strokeStyle = "rgba(157,255,191,0.18)";
  ctx.lineWidth = 3;
  ctx.beginPath();
  ctx.moveTo(margin, y0-90);
  ctx.lineTo(W-margin, y0+90);
  ctx.stroke();
  ctx.strokeStyle = "rgba(255,210,123,0.18)";
  ctx.beginPath();
  ctx.moveTo(margin, y0+90);
  ctx.lineTo(W-margin, y0-90);
  ctx.stroke();

  // motional nbar meter
  ctx.fillStyle = "rgba(232,238,247,0.92)";
  ctx.font = "14px "+getComputedStyle(document.body).fontFamily;
  ctx.fillText("Ion chain (1D axial) + motion", 16, 24);
  ctx.fillStyle = "rgba(169,183,201,0.85)";
  ctx.font = "12px "+getComputedStyle(document.body).fontFamily;
  ctx.fillText(`Spacing scale l≈${fmtSI(l, "m")}  •  n̄(axial)≈${fmt(lab.nbar,2)}`, 16, 44);

  // draw nbar bar
  const bar = {x:16, y:H-46, w:W-32, h:14};
  ctx.fillStyle = "rgba(255,255,255,0.06)";
  ctx.fillRect(bar.x, bar.y, bar.w, bar.h);
  const u = clamp(Math.log10(1+lab.nbar)/Math.log10(1+200), 0, 1);
  ctx.fillStyle = "rgba(157,255,191,0.65)";
  ctx.fillRect(bar.x, bar.y, bar.w*u, bar.h);
  ctx.strokeStyle = "rgba(255,255,255,0.10)";
  ctx.strokeRect(bar.x, bar.y, bar.w, bar.h);
  ctx.fillStyle = "rgba(169,183,201,0.85)";
  ctx.fillText("0", bar.x, bar.y-6);
  ctx.textAlign="right";
  ctx.fillText("~200", bar.x+bar.w, bar.y-6);
  ctx.textAlign="left";
}

function drawPulseTimeline(ops){
  const cv = ui.cvPulse;
  const ctx = clearCanvas(cv);
  const W=cv.width, H=cv.height;

  ctx.fillStyle = "rgba(232,238,247,0.92)";
  ctx.font = "14px "+getComputedStyle(document.body).fontFamily;
  ctx.fillText("Pulse schedule (schematic)", 16, 24);

  if (!ops || ops.length===0){
    ctx.fillStyle = "rgba(169,183,201,0.8)";
    ctx.fillText("No program compiled.", 16, 48);
    return;
  }
  let tEnd = 0;
  for (const op of ops) tEnd = Math.max(tEnd, op.t0 + op.dt);
  tEnd = Math.max(tEnd, 1e-6);
  const plot = {x:20,y:60,w:W-40,h:H-90};
  // lane mapping
  const lanes = ["PUMP_DOWN","OVEN","PI","DOPPLER","SIDEBAND","OPTPUMP","RAMAN","MS","VZ","MEASURE","H","S","SDG","X","Y","Z","CX","CZ"];
  const laneIndex = (cmd)=>{
    const k = cmd.toUpperCase();
    const idx = lanes.indexOf(k);
    return idx>=0 ? idx : lanes.length-1;
  }
  const laneH = plot.h / 8;
  function yLane(cmd){
    // group into 8 bands
    const k = cmd.toUpperCase();
    if (["PUMP_DOWN","OVEN","PI"].includes(k)) return 0;
    if (["DOPPLER","SIDEBAND","OPTPUMP"].includes(k)) return 1;
    if (["RAMAN","H","S","SDG","X","Y","Z","VZ"].includes(k)) return 2;
    if (["MS","CX","CZ"].includes(k)) return 3;
    if (["MEASURE"].includes(k)) return 4;
    return 5;
  }
  // axes
  ctx.strokeStyle="rgba(255,255,255,0.08)";
  ctx.lineWidth=1;
  for (let i=0;i<=10;i++){
    const x = plot.x + plot.w*i/10;
    ctx.beginPath(); ctx.moveTo(x, plot.y); ctx.lineTo(x, plot.y+plot.h); ctx.stroke();
  }
  // lane labels
  ctx.fillStyle="rgba(169,183,201,0.85)";
  ctx.font="12px "+getComputedStyle(document.body).fontFamily;
  const labels = ["vacuum/loading","cooling","1Q control","2Q bus","readout"];
  for (let l=0;l<labels.length;l++){
    ctx.fillText(labels[l], plot.x, plot.y + laneH*(l+0.7));
    ctx.strokeStyle="rgba(255,255,255,0.08)";
    ctx.beginPath(); ctx.moveTo(plot.x, plot.y+laneH*(l+1)); ctx.lineTo(plot.x+plot.w, plot.y+laneH*(l+1)); ctx.stroke();
  }

  function xOf(t){ return plot.x + (t/tEnd)*plot.w; }

  for (const op of ops){
    const k = op.cmd.toUpperCase();
    const lane = yLane(k);
    const y = plot.y + laneH*lane + 12;
    const h = laneH*0.6;
    const x0 = xOf(op.t0);
    const x1 = xOf(op.t0 + op.dt);
    const w = Math.max(2, x1-x0);
    let col = "rgba(123,220,255,0.22)";
    if (["MS","CX","CZ"].includes(k)) col="rgba(157,255,191,0.20)";
    if (["MEASURE"].includes(k)) col="rgba(255,210,123,0.20)";
    if (["PUMP_DOWN","OVEN","PI"].includes(k)) col="rgba(180,160,255,0.15)";
    ctx.fillStyle=col;
    ctx.fillRect(x0,y,w,h);
    ctx.strokeStyle="rgba(255,255,255,0.10)";
    ctx.strokeRect(x0,y,w,h);
    ctx.fillStyle="rgba(232,238,247,0.85)";
    ctx.font="11px "+getComputedStyle(document.body).fontFamily;
    ctx.fillText(k, x0+4, y+12);
  }

  // total time
  ctx.fillStyle="rgba(169,183,201,0.85)";
  ctx.font="12px "+getComputedStyle(document.body).fontFamily;
  ctx.fillText(`Total sequence time ≈ ${fmtSI(tEnd, "s")}`, plot.x, plot.y+plot.h+24);
}

function drawReadout(brightHist, darkHist){
  const cv = ui.cvReadout;
  const ctx = clearCanvas(cv);
  const W=cv.width, H=cv.height;

  ctx.fillStyle = "rgba(232,238,247,0.92)";
  ctx.font = "14px "+getComputedStyle(document.body).fontFamily;
  ctx.fillText("Readout photon counts (ion 0 histogram)", 16, 24);

  const thresh = parseFloat(ui.numThresh.value);

  // Build histogram bins 0..max
  const all = (brightHist||[]).concat(darkHist||[]);
  const maxC = Math.max(40, ...all, thresh+10);
  const bins = Math.min(60, maxC+1);
  const bright = new Array(bins).fill(0);
  const dark = new Array(bins).fill(0);

  for (const c of brightHist||[]){
    bright[Math.min(bins-1, c)]++;
  }
  for (const c of darkHist||[]){
    dark[Math.min(bins-1, c)]++;
  }
  const maxY = Math.max(1, ...bright, ...dark);

  const plot = {x:50,y:60,w:W-70,h:H-90};
  // axes
  ctx.strokeStyle="rgba(255,255,255,0.10)";
  ctx.beginPath(); ctx.moveTo(plot.x, plot.y); ctx.lineTo(plot.x, plot.y+plot.h); ctx.lineTo(plot.x+plot.w, plot.y+plot.h); ctx.stroke();

  const barW = plot.w / bins;
  for (let i=0;i<bins;i++){
    const x = plot.x + i*barW;
    const hb = (bright[i]/maxY)*plot.h;
    const hd = (dark[i]/maxY)*plot.h;
    // dark bars (bottom)
    ctx.fillStyle="rgba(123,220,255,0.30)";
    ctx.fillRect(x, plot.y+plot.h-hd, barW*0.9, hd);
    // bright overlay
    ctx.fillStyle="rgba(157,255,191,0.25)";
    ctx.fillRect(x, plot.y+plot.h-hb, barW*0.9, hb);
  }

  // threshold line
  const xT = plot.x + thresh*barW;
  ctx.setLineDash([6,6]);
  ctx.strokeStyle="rgba(255,210,123,0.85)";
  ctx.beginPath(); ctx.moveTo(xT, plot.y); ctx.lineTo(xT, plot.y+plot.h); ctx.stroke();
  ctx.setLineDash([]);
  ctx.fillStyle="rgba(255,210,123,0.85)";
  ctx.fillText(`threshold=${thresh}`, xT+6, plot.y+16);

  ctx.fillStyle="rgba(169,183,201,0.85)";
  ctx.font="12px "+getComputedStyle(document.body).fontFamily;
  ctx.fillText("Counts", plot.x+plot.w-50, plot.y+plot.h+22);
  ctx.save();
  ctx.translate(16, plot.y+plot.h/2);
  ctx.rotate(-Math.PI/2);
  ctx.fillText("Occurrences (normalized)", 0, 0);
  ctx.restore();
  ctx.fillStyle="rgba(169,183,201,0.85)";
  ctx.fillText(`dark shots: ${(darkHist||[]).length}`, plot.x, plot.y-10);
  ctx.fillText(`bright shots: ${(brightHist||[]).length}`, plot.x+160, plot.y-10);
}

function renderDistribution(dist, shots){
  // show top bitstrings
  const entries = Array.from(dist.entries()).sort((a,b)=>b[1]-a[1]);
  ui.tblOut.innerHTML = "";
  const maxRows = 16;
  for (let i=0;i<Math.min(maxRows, entries.length); i++){
    const [bits, c] = entries[i];
    const p = c/shots;
    const tr = document.createElement("tr");
    tr.innerHTML = `<td class="mono"><b>${bits}</b></td><td>${c}</td><td>${(100*p).toFixed(2)}%</td>`;
    ui.tblOut.appendChild(tr);
  }
  if (entries.length===0){
    const tr = document.createElement("tr");
    tr.innerHTML = `<td colspan="3" class="tiny">No results.</td>`;
    ui.tblOut.appendChild(tr);
  }
}

// ---------- animation loop ----------
let last = performance.now();
function frame(now){
  const dt = Math.min(0.05, (now-last)/1000);
  last = now;
  stepLab(dt);
  drawEnv();
  drawIons();
  requestAnimationFrame(frame);
}

// init
resetLab();
updateTemplate();
drawPulseTimeline(parseProgram(ui.txtProgram.value));
drawReadout([],[]);
requestAnimationFrame(frame);
</script>
</body>
</html>
