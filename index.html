<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Quantum Ion Lab Simulator (Single-File)</title>
  <style>
    :root{
      --bg:#0b0f14;
      --panel:rgba(255,255,255,.04);
      --panel2:rgba(255,255,255,.03);
      --stroke:rgba(255,255,255,.10);
      --stroke2:rgba(255,255,255,.18);
      --text:#e9f0fb;
      --muted:#a7b4c8;
      --ok:#2fe39a;
      --warn:#ffd27b;
      --bad:#ff6b6b;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace;
    }

    *{ box-sizing:border-box; }
    html,body{ height:100%; }
    body{
      margin:0;
      background:var(--bg);
      color:var(--text);
      font-family:system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
      letter-spacing:.1px;
    }

    header{
      padding:14px 14px 0;
      display:flex;
      align-items:flex-end;
      justify-content:space-between;
      gap:12px;
    }
    header h1{
      margin:0;
      font-size:18px;
      font-weight:700;
    }
    header .sub{
      margin:4px 0 0;
      color:var(--muted);
      font-size:12px;
    }

    .statusline{
      display:flex;
      align-items:center;
      gap:10px;
      padding-bottom:4px;
    }
    .dot{
      width:10px;height:10px;border-radius:50%;
      background:var(--warn);
      box-shadow:0 0 10px rgba(255,210,123,.35);
    }
    .pill{
      border:1px solid var(--stroke);
      background:var(--panel2);
      border-radius:999px;
      padding:6px 10px;
      font-size:12px;
      color:var(--muted);
      display:flex;
      gap:10px;
      align-items:center;
      white-space:nowrap;
    }
    .pill strong{ color:var(--text); font-weight:700; }

    .wrap{
      padding:14px;
      display:grid;
      grid-template-columns: 390px 1fr;
      gap:14px;
    }

    .panel{
      border:1px solid var(--stroke);
      background:var(--panel);
      border-radius:14px;
      padding:12px;
    }
    .panel h2{
      margin:0 0 10px;
      font-size:13px;
      font-weight:800;
      letter-spacing:.2px;
    }
    .panel h3{
      margin:12px 0 8px;
      font-size:12px;
      font-weight:800;
      color:var(--muted);
      letter-spacing:.2px;
    }

    .mono{ font-family:var(--mono); }

    .grid2{ display:grid; grid-template-columns:1fr 1fr; gap:10px; }
    .grid3{ display:grid; grid-template-columns:1fr 1fr 1fr; gap:10px; }
    .row{ display:flex; gap:10px; align-items:center; }
    .row.wrap{ flex-wrap:wrap; }
    .stack{ display:flex; flex-direction:column; gap:10px; }
    .sep{ height:1px; background:var(--stroke); margin:10px 0; }

    label{
      display:flex;
      flex-direction:column;
      gap:6px;
      font-size:12px;
      color:var(--muted);
    }

    input[type="number"], input[type="text"], textarea, select{
      width:100%;
      border-radius:10px;
      border:1px solid var(--stroke);
      background:rgba(0,0,0,.25);
      color:var(--text);
      padding:8px 10px;
      outline:none;
    }
    input[type="range"]{ width:100%; }
    textarea{
      min-height:110px;
      resize:vertical;
      font-family:var(--mono);
      line-height:1.35;
      font-size:12px;
    }

    button{
      border:1px solid var(--stroke2);
      background:rgba(255,255,255,.05);
      color:var(--text);
      border-radius:12px;
      padding:9px 10px;
      cursor:pointer;
      font-weight:700;
      font-size:12px;
    }
    button:hover{ background:rgba(255,255,255,.08); }
    button:active{ transform:translateY(1px); }

    .kv{
      display:grid;
      grid-template-columns: 1fr auto;
      gap:8px 10px;
      font-size:12px;
      color:var(--muted);
      align-items:center;
    }
    .kv .k{ color:var(--muted); }
    .kv .v{ font-family:var(--mono); color:var(--text); }

    .spark{
      width:10px;height:10px;border-radius:50%;
      background:var(--warn);
      box-shadow:0 0 10px rgba(255,210,123,.25);
      border:1px solid rgba(255,255,255,.12);
      flex:0 0 auto;
    }
    .spark.ok{ background:var(--ok); box-shadow:0 0 10px rgba(47,227,154,.25); }
    .spark.warn{ background:var(--warn); box-shadow:0 0 10px rgba(255,210,123,.25); }
    .spark.bad{ background:var(--bad); box-shadow:0 0 10px rgba(255,107,107,.25); }

    .cv{
      width:100%;
      height:240px;
      display:block;
      border-radius:12px;
      border:1px solid var(--stroke);
      background:rgba(0,0,0,.18);
    }
    .cv.tall{ height:300px; }
    .cv.short{ height:180px; }

    table{
      width:100%;
      border-collapse:collapse;
      font-size:12px;
    }
    th,td{
      border-bottom:1px solid var(--stroke);
      padding:8px 6px;
      text-align:left;
    }
    th{
      color:var(--muted);
      font-weight:800;
    }

    .log{
      font-family:var(--mono);
      font-size:12px;
      line-height:1.35;
      color:var(--text);
      white-space:pre-wrap;
      margin:0;
      max-height:180px;
      overflow:auto;
      border-radius:12px;
      border:1px solid var(--stroke);
      background:rgba(0,0,0,.25);
      padding:10px;
    }

    .right{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:14px;
      align-content:start;
    }
    .span2{ grid-column:1 / span 2; }

    @media (max-width: 1080px){
      .wrap{ grid-template-columns: 1fr; }
      .right{ grid-template-columns:1fr; }
      .span2{ grid-column:auto; }
    }
  </style>
</head>

<body>
  <header>
    <div>
      <h1>Quantum Ion Lab Simulator</h1>
      <div class="sub">Vacuum + loading + pulse program + readout + camera + lasers + micromotion (single-file demo).</div>
    </div>
    <div class="statusline">
      <div class="pill">
        <span id="dotReady" class="dot" aria-hidden="true"></span>
        <strong id="readyTxt">INIT</strong>
      </div>
    </div>
  </header>

  <div class="wrap">
    <!-- LEFT COLUMN -->
    <div class="stack">
      <div class="panel">
        <h2>Vacuum, Oven, Loading</h2>

        <div class="grid2">
          <label>
            Base pressure
            <select id="selBaseP">
              <option value="1e-12">1×10⁻¹² mbar</option>
              <option value="3e-12">3×10⁻¹² mbar</option>
              <option value="1e-11" selected>1×10⁻¹¹ mbar</option>
              <option value="3e-11">3×10⁻¹¹ mbar</option>
              <option value="1e-10">1×10⁻¹⁰ mbar</option>
            </select>
          </label>

          <label>
            PI scheme
            <select id="selPI">
              <option value="none">None</option>
              <option value="ca40" selected>Ca-40 (example)</option>
              <option value="ca44">Ca-44 (example)</option>
            </select>
          </label>
        </div>

        <div class="grid2" style="margin-top:10px;">
          <label>
            Pump speed <span class="mono">(<span id="txtPump">65</span>%)</span>
            <input id="rngPump" type="range" min="0" max="100" value="65" />
          </label>

          <label>
            Oven set <span class="mono">(<span id="txtOvenSet">40</span>%)</span>
            <input id="rngOven" type="range" min="0" max="100" value="40" />
          </label>
        </div>

        <div class="row wrap" style="margin-top:10px;">
          <button id="btnPump" type="button">Pump</button>
          <button id="btnBake" type="button">Bake</button>
          <button id="btnOven" type="button">Oven</button>
          <button id="btnLoad" type="button">Load Ions</button>
          <button id="btnCool" type="button">Cool</button>
          <button id="btnReset" type="button">Reset</button>
        </div>

        <div class="sep"></div>
        <div class="kv">
          <div class="k">Pressure</div><div class="v" id="kvPressure">—</div>
          <div class="k">Oven temp</div><div class="v" id="kvOven">—</div>
          <div class="k">RF drive</div><div class="v" id="kvRF">—</div>
          <div class="k">ωz estimate</div><div class="v" id="kvWz">—</div>
          <div class="k">Ions</div><div class="v" id="kvIons">—</div>
          <div class="k">n̄</div><div class="v" id="kvNbar">—</div>
        </div>

        <h3>Vacuum View</h3>
        <canvas id="cvEnv" class="cv short"></canvas>
      </div>

      <div class="panel">
        <h2>Trap & Fields</h2>
        <div class="grid3">
          <label>RF f (MHz)<input id="numRFf" type="number" value="28.6" step="0.1" /></label>
          <label>RF V (Vpp)<input id="numRFv" type="number" value="180" step="1" /></label>
          <label>B (mT)<input id="numB" type="number" value="0.45" step="0.01" /></label>
        </div>
        <div class="grid2" style="margin-top:10px;">
          <label>ωz (MHz)<input id="numWz" type="number" value="1.10" step="0.01" /></label>
          <label>ωr (MHz)<input id="numWr" type="number" value="3.60" step="0.05" /></label>
        </div>

        <h3>Ions</h3>
        <canvas id="cvIons" class="cv"></canvas>
      </div>

      <div class="panel">
        <h2>Pulse Program</h2>

        <div class="grid2">
          <label>
            Template
            <select id="selTemplate">
              <option value="ramsey" selected>Ramsey</option>
              <option value="ms">MS Gate</option>
              <option value="rabi">Rabi</option>
              <option value="readout">Readout Only</option>
            </select>
          </label>
          <div class="row" style="align-items:flex-end;">
            <button id="btnCompile" type="button" style="flex:1;">Compile</button>
            <button id="btnRun" type="button" style="flex:1;">Run</button>
          </div>
        </div>

        <label style="margin-top:10px;">
          Program (one op per line)
          <textarea id="txtProgram" spellcheck="false"></textarea>
        </label>

        <h3>Pulse Timeline</h3>
        <canvas id="cvPulse" class="cv short"></canvas>
      </div>

      <div class="panel">
        <h2>Shot & Noise Model</h2>

        <div class="grid3">
          <label>Qubits<input id="numQ" type="number" min="1" max="16" value="4" step="1" /></label>
          <label>Shots<input id="numShots" type="number" min="1" max="50000" value="2000" step="100" /></label>
          <label>Sensor
            <select id="selSensor">
              <option value="pmts" selected>PMTs</option>
              <option value="camera">Camera</option>
            </select>
          </label>
        </div>

        <div class="grid3" style="margin-top:10px;">
          <label>XTalk (0–1)<input id="numXtalk" type="number" value="0.05" min="0" max="1" step="0.01" /></label>
          <label>T2 (ms)<input id="numT2" type="number" value="25" min="0.1" step="0.5" /></label>
          <label>Heat (q/ms)<input id="numHeat" type="number" value="0.03" min="0" step="0.01" /></label>
        </div>

        <div class="grid2" style="margin-top:10px;">
          <label>Two-qubit p1 (1q proxy)<input id="numP1" type="number" value="0.006" min="0" max="1" step="0.001" /></label>
          <label>Two-qubit p2 (corr)<input id="numP2" type="number" value="0.002" min="0" max="1" step="0.001" /></label>
        </div>
      </div>

      <div class="panel">
        <h2>Readout</h2>
        <div class="grid3">
          <label>Det. time (µs)<input id="numDetT" type="number" value="200" step="10" /></label>
          <label>Bright μ (cts)<input id="numBright" type="number" value="26" step="1" /></label>
          <label>Dark μ (cts)<input id="numDark" type="number" value="3" step="1" /></label>
        </div>

        <div class="grid3" style="margin-top:10px;">
          <label>Threshold (cts)<input id="numThresh" type="number" value="12" step="1" /></label>
          <label>Classifier
            <select id="selClassifier">
              <option value="threshold" selected>Threshold</option>
              <option value="naivebayes">Naive Bayes</option>
              <option value="llr">LLR (slider)</option>
            </select>
          </label>
          <label>LLR <span class="mono">(<span id="txtLLR">0.0</span>)</span>
            <input id="rngLLR" type="range" min="-6" max="6" value="0" step="0.1" />
          </label>
        </div>

        <div class="grid3" style="margin-top:10px;">
          <label>Bin (µs)<input id="numBinUs" type="number" value="5" step="1" /></label>
          <label>Depump (Hz)<input id="numDepump" type="number" value="700" step="50" /></label>
          <label>Pump (Hz)<input id="numPump" type="number" value="250" step="25" /></label>
        </div>

        <div class="sep"></div>
        <div class="kv">
          <div class="k">SPAM estimate</div><div class="v" id="txtSpam">—</div>
          <div class="k">Counts model</div><div class="v" id="txtCountsPhysical">—</div>
        </div>

        <h3>Readout Histogram</h3>
        <canvas id="cvReadout" class="cv short"></canvas>

        <h3>Outcome Distribution</h3>
        <canvas id="cvDist" class="cv short"></canvas>

        <h3>Top outcomes</h3>
        <table class="mono">
          <thead>
            <tr>
              <th style="width:40%;">bitstring</th>
              <th style="width:30%;">p</th>
              <th style="width:30%;">N</th>
            </tr>
          </thead>
          <tbody id="tblOut"></tbody>
        </table>
      </div>

      <div class="panel">
        <h2>Laser Rack</h2>

        <div class="grid2">
          <label class="row" style="flex-direction:row;justify-content:space-between;">
            <span>369 nm lock</span>
            <span class="row" style="gap:8px;">
              <input id="chkL369" type="checkbox" checked />
              <span id="spL369" class="spark ok" title="lock status"></span>
            </span>
          </label>

          <label class="row" style="flex-direction:row;justify-content:space-between;">
            <span>399 nm lock</span>
            <span class="row" style="gap:8px;">
              <input id="chkL399" type="checkbox" checked />
              <span id="spL399" class="spark ok"></span>
            </span>
          </label>

          <label class="row" style="flex-direction:row;justify-content:space-between;">
            <span>935 nm lock</span>
            <span class="row" style="gap:8px;">
              <input id="chkL935" type="checkbox" checked />
              <span id="spL935" class="spark ok"></span>
            </span>
          </label>

          <label class="row" style="flex-direction:row;justify-content:space-between;">
            <span>355 nm lock</span>
            <span class="row" style="gap:8px;">
              <input id="chkL355" type="checkbox" checked />
              <span id="spL355" class="spark ok"></span>
            </span>
          </label>

          <label class="row" style="flex-direction:row;justify-content:space-between;">
            <span>638 nm lock</span>
            <span class="row" style="gap:8px;">
              <input id="chkL638" type="checkbox" checked />
              <span id="spL638" class="spark ok"></span>
            </span>
          </label>

          <div class="kv" style="grid-column:1 / span 2;">
            <div class="k">369 err</div><div class="v" id="txtL369Err">—</div>
            <div class="k">399 err</div><div class="v" id="txtL399Err">—</div>
            <div class="k">935 err</div><div class="v" id="txtL935Err">—</div>
            <div class="k">355 err</div><div class="v" id="txtL355Err">—</div>
            <div class="k">638 err</div><div class="v" id="txtL638Err">—</div>
          </div>
        </div>

        <div class="row wrap" style="margin-top:10px;">
          <button id="btnLockAll" type="button">Lock all</button>
          <button id="btnUnlockAll" type="button">Unlock all</button>
          <button id="btnKickLasers" type="button">Kick</button>
        </div>

        <h3>Laser Diagnostics</h3>
        <canvas id="cvLaser" class="cv short"></canvas>
      </div>

      <div class="panel">
        <h2>Micromotion</h2>
        <div class="grid2">
          <label>Comp X (V)<input id="numCompX" type="number" value="0.00" step="0.02" /></label>
          <label>Comp Y (V)<input id="numCompY" type="number" value="0.00" step="0.02" /></label>
        </div>

        <div class="sep"></div>
        <div class="kv">
          <div class="k">MM amp</div><div class="v" id="txtMMamp">—</div>
          <div class="k">SB ratio</div><div class="v" id="txtMMratio">—</div>
        </div>

        <div class="row wrap" style="margin-top:10px;">
          <button id="btnAutoMM" type="button">Auto-minimize</button>
        </div>

        <h3>MM Diagnostic</h3>
        <canvas id="cvMM" class="cv short"></canvas>
      </div>

      <div class="panel">
        <h2>Camera View</h2>

        <!-- Fixed markup: ensure labels are closed, and keep controls + canvas neatly grouped -->
        <div class="row wrap">
          <label style="flex:1; min-width:150px;">
            Mode
            <select id="selCamMode">
              <option value="counts" selected>Counts</option>
              <option value="image">Image</option>
            </select>
          </label>

          <label style="flex:1; min-width:150px;">
            Gain <span class="mono">(<span id="txtCamGain">1.0</span>×)</span>
            <input id="rngCamGain" type="range" min="0.5" max="5" step="0.1" value="1.0" />
          </label>
        </div>

        <div class="row wrap" style="margin-top:10px;">
          <label style="flex:1; min-width:150px;">
            Blur σ <span class="mono">(<span id="txtCamSigma">1.0</span> px)</span>
            <input id="rngCamSigma" type="range" min="0.4" max="3.0" step="0.1" value="1.0" />
          </label>

          <label style="flex:1; min-width:150px;">
            Pixel scale (µm/px)
            <input id="numCamScale" type="number" value="1.2" step="0.1" />
          </label>
        </div>

        <div class="row wrap" style="margin-top:10px;">
          <label style="flex:1; min-width:150px;">
            ROI half-width (px)
            <input id="numCamROI" type="number" value="14" step="1" min="4" />
          </label>

          <label style="flex:1; min-width:150px;">
            Overlay
            <select id="selCamOverlay">
              <option value="none" selected>None</option>
              <option value="roi">ROI</option>
              <option value="centroid">Centroid</option>
            </select>
          </label>
        </div>

        <h3>Camera</h3>
        <canvas id="cvCam" class="cv"></canvas>
      </div>

      <div class="panel">
        <h2>Calibration</h2>
        <div class="sub mono" style="color:var(--muted); font-size:12px;">
          (Placeholder plot — fill with your scan routines if desired.)
        </div>
        <h3>Calibration Plot</h3>
        <canvas id="cvCal" class="cv short"></canvas>

        <h3>Calibration Log</h3>
        <table class="mono">
          <thead>
            <tr>
              <th style="width:22%;">type</th>
              <th style="width:22%;">x</th>
              <th style="width:22%;">y</th>
              <th style="width:34%;">note</th>
            </tr>
          </thead>
          <tbody id="tblCal"></tbody>
        </table>
      </div>

      <div class="panel">
        <h2>Log</h2>
        <pre id="log" class="log"></pre>
      </div>
    </div>

    <!-- RIGHT COLUMN -->
    <div class="right">
      <div class="panel span2">
        <h2>Photon Trace</h2>
        <canvas id="cvPhoton" class="cv short"></canvas>
      </div>

      <div class="panel">
        <h2>MS Diagnostic</h2>
        <canvas id="cvMS" class="cv short"></canvas>
      </div>

      <div class="panel">
        <h2>Spare</h2>
        <div class="sub" style="color:var(--muted); font-size:12px;">Reserved for extra plots / scans.</div>
        <canvas class="cv short"></canvas>
      </div>
    </div>
  </div>

  <script type="module">
    /********************
     * Utility & UI cache
     ********************/
    const $ = (id) => document.getElementById(id);

    const ui = {
      // canvases
      cvEnv: $('cvEnv'),
      cvIons: $('cvIons'),
      cvPulse: $('cvPulse'),
      cvReadout: $('cvReadout'),
      cvDist: $('cvDist'),
      cvCam: $('cvCam'),
      cvPhoton: $('cvPhoton'),
      cvMS: $('cvMS'),
      cvLaser: $('cvLaser'),
      cvMM: $('cvMM'),
      cvCal: $('cvCal'),

      // log
      log: $('log'),

      // status / kv
      dotReady: $('dotReady'),
      readyTxt: $('readyTxt'),
      kvPressure: $('kvPressure'),
      kvOven: $('kvOven'),
      kvRF: $('kvRF'),
      kvWz: $('kvWz'),
      kvIons: $('kvIons'),
      kvNbar: $('kvNbar'),

      // vacuum controls
      selBaseP: $('selBaseP'),
      rngPump: $('rngPump'),
      txtPump: $('txtPump'),
      rngOven: $('rngOven'),
      txtOvenSet: $('txtOvenSet'),
      selPI: $('selPI'),
      btnPump: $('btnPump'),
      btnBake: $('btnBake'),
      btnOven: $('btnOven'),
      btnLoad: $('btnLoad'),
      btnCool: $('btnCool'),
      btnReset: $('btnReset'),

      // trap numbers
      numRFf: $('numRFf'),
      numRFv: $('numRFv'),
      numWz: $('numWz'),
      numWr: $('numWr'),
      numB: $('numB'),

      // program
      txtProgram: $('txtProgram'),
      selTemplate: $('selTemplate'),
      btnCompile: $('btnCompile'),
      btnRun: $('btnRun'),

      // shots & noise
      numQ: $('numQ'),
      numShots: $('numShots'),
      selSensor: $('selSensor'),
      numXtalk: $('numXtalk'),
      numT2: $('numT2'),
      numHeat: $('numHeat'),
      numP1: $('numP1'),
      numP2: $('numP2'),

      // readout
      numDetT: $('numDetT'),
      numBright: $('numBright'),
      numDark: $('numDark'),
      numThresh: $('numThresh'),
      selClassifier: $('selClassifier'),
      numBinUs: $('numBinUs'),
      numDepump: $('numDepump'),
      numPump: $('numPump'),
      rngLLR: $('rngLLR'),
      txtLLR: $('txtLLR'),
      txtSpam: $('txtSpam'),
      txtCountsPhysical: $('txtCountsPhysical'),

      // micromotion
      numCompX: $('numCompX'),
      numCompY: $('numCompY'),
      txtMMamp: $('txtMMamp'),
      txtMMratio: $('txtMMratio'),
      btnAutoMM: $('btnAutoMM'),

      // lasers
      chkL369: $('chkL369'),
      chkL399: $('chkL399'),
      chkL935: $('chkL935'),
      chkL355: $('chkL355'),
      chkL638: $('chkL638'),
      txtL369Err: $('txtL369Err'),
      txtL399Err: $('txtL399Err'),
      txtL935Err: $('txtL935Err'),
      txtL355Err: $('txtL355Err'),
      txtL638Err: $('txtL638Err'),
      spL369: $('spL369'),
      spL399: $('spL399'),
      spL935: $('spL935'),
      spL355: $('spL355'),
      spL638: $('spL638'),
      btnLockAll: $('btnLockAll'),
      btnUnlockAll: $('btnUnlockAll'),
      btnKickLasers: $('btnKickLasers'),

      // camera
      selCamMode: $('selCamMode'),
      rngCamGain: $('rngCamGain'),
      txtCamGain: $('txtCamGain'),
      rngCamSigma: $('rngCamSigma'),
      txtCamSigma: $('txtCamSigma'),
      numCamScale: $('numCamScale'),
      numCamROI: $('numCamROI'),
      selCamOverlay: $('selCamOverlay'),

      // tables
      tblOut: $('tblOut'),
      tblCal: $('tblCal'),
    };

    const nowMs = () => performance.now();

    function log(msg){
      const t = new Date().toLocaleTimeString();
      ui.log.textContent += `[${t}] ${msg}\n`;
      ui.log.scrollTop = ui.log.scrollHeight;
    }

    /********************
     * Canvas helpers
     ********************/
    function ensureCanvas(c){
      if(!c) return null;
      const dpr = Math.max(1, window.devicePixelRatio || 1);
      const w = Math.max(2, Math.floor(c.clientWidth * dpr));
      const h = Math.max(2, Math.floor(c.clientHeight * dpr));
      if(c.width !== w || c.height !== h){
        c.width = w; c.height = h;
      }
      return c.getContext('2d');
    }

    function clear(ctx){
      const c = ctx.canvas;
      ctx.clearRect(0,0,c.width,c.height);
    }

    function axes(ctx, title){
      const c = ctx.canvas;
      ctx.save();
      ctx.globalAlpha = 1;
      ctx.fillStyle = 'rgba(255,255,255,.08)';
      ctx.fillRect(0,0,c.width,c.height);
      ctx.strokeStyle = 'rgba(255,255,255,.12)';
      ctx.lineWidth = 2;
      ctx.strokeRect(2,2,c.width-4,c.height-4);

      ctx.fillStyle = 'rgba(255,255,255,.75)';
      ctx.font = `bold ${Math.max(12, Math.floor(c.height/16))}px ${getComputedStyle(document.body).fontFamily}`;
      ctx.fillText(title, 10, 22);
      ctx.restore();
    }

    function map(x, a,b, c,d){
      if(b===a) return (c+d)/2;
      return c + (x-a)*(d-c)/(b-a);
    }

    /********************
     * Simple physics / state
     ********************/
    const lab = {
      t: 0,
      last: nowMs(),
      baseP: 1e-11,
      pumpOn: false,
      bakeOn: false,
      ovenOn: false,
      ovenSet: 0.4, // 0..1
      pumpSpeed: 0.65, // 0..1

      pressure: 1e-9,
      ovenTempC: 25,
      ionsLoaded: 0,
      nbar: 8.0,

      rf: { fMHz: 28.6, vpp: 180 },
      trap: { wzMHz: 1.10, wrMHz: 3.60, BmT: 0.45 },

      ions: [],

      program: { text:'', compiled:[], lastError:null },
      cal: { points:[], tableRows:[] },

      readout: { lastBrightCounts:[], lastDarkCounts:[], lastSpam:null },

      mm: { compX: 0, compY: 0, amp: 0.25, ratio: 0.18 },

      lasers: {
        L369:{ lock:true, err:0 },
        L399:{ lock:true, err:0 },
        L935:{ lock:true, err:0 },
        L355:{ lock:true, err:0 },
        L638:{ lock:true, err:0 }
      },

      cam: {
        mode:'counts',
        gain:1.0,
        sigma:1.0,
        scaleUmPerPx:1.2,
        roiHalf:14,
        overlay:'none',
        lastImage:null,
        lastCounts:null,
        centroid:null
      }
    };

    function clamp(x, lo, hi){ return Math.min(hi, Math.max(lo, x)); }
    function randn(){
      // Box-Muller
      let u = 0, v = 0;
      while(u === 0) u = Math.random();
      while(v === 0) v = Math.random();
      return Math.sqrt(-2.0*Math.log(u)) * Math.cos(2.0*Math.PI*v);
    }
    function poisson(lambda){
      // small lambda: Knuth. good enough for a demo
      const L = Math.exp(-lambda);
      let k = 0, p = 1;
      do { k++; p *= Math.random(); } while(p > L);
      return k - 1;
    }

    // Very rough vacuum/oven model
    function pressureUpdate(dt){
      lab.baseP = parseFloat(ui.selBaseP.value);

      const targetBase = lab.baseP;
      const pump = lab.pumpOn ? (0.15 + 0.85*lab.pumpSpeed) : 0.0;
      const bake = lab.bakeOn ? 1.0 : 0.0;
      const oven = lab.ovenOn ? lab.ovenSet : 0.0;

      // outgassing increases with bake and oven
      const outgas = (1e-11)*(1 + 12*bake + 18*oven);

      // pump down towards max(targetBase+outgas, ...)
      const desired = Math.max(targetBase + outgas, 2e-12);
      const kPump = 0.65 * pump;   // faster if pump on
      const kLeak = 0.03 + 0.08*oven; // oven adds neutrals -> higher effective "leak"
      const k = kPump + kLeak;

      lab.pressure += (desired - lab.pressure) * (1 - Math.exp(-k*dt));
      lab.pressure = Math.max(2e-12, lab.pressure);
    }

    function ovenUpdate(dt){
      // thermal RC to target
      const ambient = 24;
      const target = lab.ovenOn ? (ambient + 650*lab.ovenSet) : ambient;
      const tau = lab.ovenOn ? 1.8 : 3.2; // seconds
      lab.ovenTempC += (target - lab.ovenTempC)*(1 - Math.exp(-dt/tau));
    }

    function ionsUpdate(dt){
      // heating from background + oven neutrals, cooling when "cool" toggled
      const heatBg = 0.004 + 0.03*lab.ovenSet*(lab.ovenOn ? 1:0);
      const heat = heatBg + (ui.numHeat.valueAsNumber || 0.03);
      const coolPower = (lab.coolingOn ? 1.0 : 0.0);
      const coolRate = 0.30 * coolPower; // quanta/ms

      const dn = (heat - coolRate) * dt * 1e3; // dt in s -> ms
      lab.nbar = Math.max(0.02, lab.nbar + dn);

      // lose ions if pressure high
      if(lab.ionsLoaded > 0){
        const lossRate = clamp((lab.pressure - 1e-10)/(5e-10), 0, 1) * 0.4;
        if(Math.random() < lossRate*dt){
          lab.ionsLoaded = Math.max(0, lab.ionsLoaded - 1);
          lab.ions = lab.ions.slice(0, lab.ionsLoaded);
          log(`Ion lost (pressure event). Remaining: ${lab.ionsLoaded}`);
        }
      }
    }

    function estimateWz(){
      // purely cosmetic estimate based on RF and trap knobs
      const V = lab.rf.vpp;
      const f = lab.rf.fMHz;
      const wz = Math.sqrt(Math.max(0.01, (lab.trap.wzMHz*lab.trap.wzMHz) + 1e-4*(V-120) + 1e-3*(f-25)));
      return wz;
    }

    /********************
     * Program compiler (tiny DSL)
     ********************/
    const templates = {
      ramsey: [
        'Doppler 2ms',
        'OpticalPump 200us',
        'Pi/2 10us',
        'Wait 50us',
        'Pi/2 10us',
        'Readout 200us'
      ].join('\n'),
      rabi: [
        'Doppler 2ms',
        'OpticalPump 200us',
        'Rabi 30us',
        'Readout 200us'
      ].join('\n'),
      ms: [
        'Doppler 2ms',
        'OpticalPump 200us',
        'MS 60us',
        'Readout 250us'
      ].join('\n'),
      readout: [
        'Readout 250us'
      ].join('\n'),
    };

    function parseDuration(tok){
      // accepts e.g. "200us", "2ms", "0.5s"
      const m = String(tok).trim().match(/^([0-9]*\.?[0-9]+)\s*(us|µs|ms|s)$/i);
      if(!m) return null;
      const x = parseFloat(m[1]);
      const unit = m[2].toLowerCase();
      if(unit === 'us' || unit === 'µs') return x*1e-6;
      if(unit === 'ms') return x*1e-3;
      if(unit === 's') return x;
      return null;
    }

    function compileProgram(text){
      const lines = text.split(/\r?\n/).map(s=>s.trim()).filter(Boolean);
      const ops = [];
      for(const ln of lines){
        const parts = ln.split(/\s+/);
        const op = parts[0].toLowerCase();
        const dur = parts[1] ? parseDuration(parts[1]) : null;
        if(!op) continue;

        const needsDur = !['barrier','idle'].includes(op);
        if(needsDur && (dur === null || !isFinite(dur))){
          throw new Error(`Bad duration on line: "${ln}"`);
        }
        ops.push({ op, dur: needsDur ? dur : 0, raw: ln });
      }
      return ops;
    }

    /********************
     * Minimal stabilizer / measurement model
     * (toy: generates bitstring outcomes with simple error knobs)
     ********************/
    class Stabilizer {
      constructor(n){
        this.n = n;
        this.state = new Array(n).fill(0); // computational basis "hidden" state for toy
      }
      reset(){
        this.state.fill(0);
      }
      apply(op){
        // toy effects
        if(op === 'pi' || op === 'x'){
          const i = Math.floor(Math.random()*this.n);
          this.state[i] ^= 1;
        }
        if(op === 'pi/2' || op === 'h'){
          // randomize a subset
          const p = 0.35;
          for(let i=0;i<this.n;i++){
            if(Math.random() < p) this.state[i] ^= 1;
          }
        }
        if(op === 'ms'){
          // add correlated flips
          const p2 = clamp(ui.numP2.valueAsNumber || 0.002, 0, 1);
          for(let i=0;i<this.n-1;i++){
            if(Math.random() < p2){
              this.state[i] ^= 1;
              this.state[i+1] ^= 1;
            }
          }
        }
      }
      measureAll(){
        return this.state.slice();
      }
    }
    window.StabilizerTableau = Stabilizer;

    function applyDecoherence(bits, dt){
      // dt in seconds, T2 in ms
      const T2ms = Math.max(0.1, ui.numT2.valueAsNumber || 25);
      const p = 1 - Math.exp(- (dt*1e3) / T2ms);
      for(let i=0;i<bits.length;i++){
        if(Math.random() < p*0.15){ bits[i] ^= 1; }
      }
      // independent error proxy for 2q gate infidelity
      const p1 = clamp(ui.numP1.valueAsNumber || 0.006, 0, 1);
      for(let i=0;i<bits.length;i++){
        if(Math.random() < p1){ bits[i] ^= 1; }
      }
    }

    /********************
     * Readout model
     ********************/
    function sampleCounts(bit, detT_us){
      const brightMu = ui.numBright.valueAsNumber || 26;
      const darkMu   = ui.numDark.valueAsNumber || 3;
      const depumpHz = ui.numDepump.valueAsNumber || 700;
      const pumpHz   = ui.numPump.valueAsNumber || 250;

      // effective means scale with integration time
      const t = detT_us / 200;
      let muB = brightMu * t;
      let muD = darkMu * t;

      // depump/pump: mix bright/dark
      const pBD = 1 - Math.exp(-(depumpHz)*(detT_us*1e-6));
      const pDB = 1 - Math.exp(-(pumpHz)*(detT_us*1e-6));

      if(bit === 1){ // bright
        // depump towards dark
        const mix = pBD;
        const mu = (1-mix)*muB + mix*muD;
        return poisson(Math.max(0.05, mu));
      }else{
        // pump towards bright
        const mix = pDB;
        const mu = (1-mix)*muD + mix*muB;
        return poisson(Math.max(0.05, mu));
      }
    }

    function classifyCount(k){
      const thr = ui.numThresh.valueAsNumber || 12;
      const mode = (ui.selClassifier.value || 'threshold').toLowerCase();
      if(mode === 'llr'){
        const llr = ui.rngLLR.valueAsNumber || 0;
        // treat llr as threshold shift in this toy
        return (k >= (thr + llr)) ? 1 : 0;
      }
      if(mode === 'naivebayes'){
        // crude: a soft threshold using a logistic
        const s = 1/(1 + Math.exp(-(k - thr)/2));
        return (Math.random() < s) ? 1 : 0;
      }
      return (k >= thr) ? 1 : 0;
    }

    function addCrosstalk(bits, xtalk){
      // if a bright ion, slightly increases chance neighbor is classified bright
      if(bits.length <= 1) return bits;
      const out = bits.slice();
      for(let i=0;i<bits.length;i++){
        if(bits[i] === 1){
          if(i>0 && Math.random() < xtalk*0.5) out[i-1] = 1;
          if(i<bits.length-1 && Math.random() < xtalk*0.5) out[i+1] = 1;
        }
      }
      return out;
    }

    /********************
     * Run shots
     ********************/
    function runShots(ops){
      const n = clamp(ui.numQ.valueAsNumber || 4, 1, 16) | 0;
      const shots = clamp(ui.numShots.valueAsNumber || 2000, 1, 50000) | 0;
      const xtalk = clamp(ui.numXtalk.valueAsNumber || 0.05, 0, 1);

      // load ions count in "hardware" if not present
      lab.ionsLoaded = n;
      lab.ions = makeIonChain(n);

      const tab = new Stabilizer(n);
      tab.reset();

      // program duration
      const progT = ops.reduce((s,o)=>s+o.dur,0);
      // apply toy unitary effects
      for(const o of ops){
        if(o.op === 'doppler' || o.op === 'opticalpump'){
          // cooling/pumping reduces nbar a bit
          lab.nbar = Math.max(0.02, lab.nbar - 0.20);
        }else if(o.op === 'wait'){
          applyDecoherence(tab.state, o.dur);
        }else if(o.op === 'ms'){
          tab.apply('ms');
          applyDecoherence(tab.state, o.dur);
        }else if(o.op === 'pi/2'){
          tab.apply('pi/2');
        }else if(o.op === 'pi' || o.op === 'x'){
          tab.apply('pi');
        }else if(o.op === 'rabi'){
          tab.apply('pi');
        }
      }

      const detT_us = ui.numDetT.valueAsNumber || 200;
      const sensor = (ui.selSensor.value || 'pmts').toLowerCase();

      const outcomeCounts = new Map();
      const brightCounts = [];
      const darkCounts = [];

      let totalErr = 0;

      for(let s=0; s<shots; s++){
        // hidden ideal bitstring
        const ideal = tab.measureAll().slice();

        // sample physical photon counts per ion
        const counts = new Array(n);
        for(let i=0;i<n;i++){
          counts[i] = sampleCounts(ideal[i], detT_us);
          if(ideal[i] === 1) brightCounts.push(counts[i]); else darkCounts.push(counts[i]);
        }

        // classify
        let measured = counts.map(classifyCount);
        measured = addCrosstalk(measured, xtalk);

        // camera mode: store last frame statistics
        if(sensor === 'camera'){
          lab.cam.lastCounts = counts.slice();
        }

        // error vs ideal
        for(let i=0;i<n;i++){
          if(measured[i] !== ideal[i]) totalErr++;
        }

        const bits = measured.map(b=>b?1:0).join('');
        outcomeCounts.set(bits, (outcomeCounts.get(bits)||0) + 1);
      }

      // SPAM estimate (bit error)
      const spam = totalErr / (shots*n);
      lab.readout.lastSpam = spam;
      lab.readout.lastBrightCounts = brightCounts;
      lab.readout.lastDarkCounts = darkCounts;

      // normalize distribution
      const outcomes = [...outcomeCounts.entries()]
        .map(([bits, c]) => ({bits, c, p: c/shots}))
        .sort((a,b)=> b.c - a.c);

      renderDistributionTable(outcomes);
      drawDist(outcomes);
      drawReadout(brightCounts, darkCounts);

      // update camera with synthetic image based on last counts
      if(sensor === 'camera'){
        makeCameraFrameFromCounts(lab.cam.lastCounts || new Array(n).fill(0));
      }

      log(`Run: n=${n}, shots=${shots}, T≈${(progT*1e3).toFixed(2)} ms, SPAM≈${(spam*100).toFixed(2)}%`);
    }

    function makeIonChain(n){
      const xs = [];
      const spacing = 1;
      const mid = (n-1)/2;
      for(let i=0;i<n;i++) xs.push((i-mid)*spacing);
      return xs.map((x,i)=>({x, y:0, i}));
    }

    /********************
     * Camera frame synthesis
     ********************/
    function gaussian2D(x,y,s){
      const ss = s*s;
      return Math.exp(-(x*x + y*y)/(2*ss));
    }

    function makeCameraFrameFromCounts(counts){
      const ctx = ensureCanvas(ui.cvCam);
      if(!ctx) return;

      const n = counts.length;
      const w = ctx.canvas.width;
      const h = ctx.canvas.height;

      // image buffer (grayscale)
      const img = new Float32Array(w*h);
      img.fill(0);

      const sigma = lab.cam.sigma;
      const gain = lab.cam.gain;

      // map ion chain into camera coordinates
      const cx = w*0.5;
      const cy = h*0.52;
      const pitch = Math.min(w,h) / Math.max(10, n+2);

      const xs = [];
      for(let i=0;i<n;i++){
        xs.push(cx + (i - (n-1)/2)*pitch);
      }

      for(let i=0;i<n;i++){
        const amp = gain * (counts[i] || 0);
        const xi = xs[i];
        const yi = cy;
        const r = Math.ceil(4*sigma);
        const x0 = Math.max(0, Math.floor(xi - r));
        const x1 = Math.min(w-1, Math.floor(xi + r));
        const y0 = Math.max(0, Math.floor(yi - r));
        const y1 = Math.min(h-1, Math.floor(yi + r));
        for(let yy=y0; yy<=y1; yy++){
          for(let xx=x0; xx<=x1; xx++){
            img[yy*w + xx] += amp * gaussian2D(xx-xi, yy-yi, sigma);
          }
        }
      }

      // background + shot noise
      for(let i=0;i<img.length;i++){
        img[i] += 2 + 0.12*Math.abs(randn());
      }

      // compute centroid in ROI (optional)
      const roiHalf = Math.max(4, lab.cam.roiHalf|0);
      const roiX0 = Math.max(0, (cx - roiHalf)|0);
      const roiX1 = Math.min(w-1, (cx + roiHalf)|0);
      const roiY0 = Math.max(0, (cy - roiHalf)|0);
      const roiY1 = Math.min(h-1, (cy + roiHalf)|0);

      let sI=0, sX=0, sY=0;
      for(let yy=roiY0; yy<=roiY1; yy++){
        for(let xx=roiX0; xx<=roiX1; xx++){
          const v = img[yy*w+xx];
          sI += v;
          sX += v*xx;
          sY += v*yy;
        }
      }
      lab.cam.centroid = (sI>0) ? {x:sX/sI, y:sY/sI} : null;

      // store for renderer
      lab.cam.lastImage = img;
    }

    /********************
     * Renderers
     ********************/
    function drawVacuum(){
      const ctx = ensureCanvas(ui.cvEnv);
      if(!ctx) return;
      clear(ctx);
      axes(ctx, 'Vacuum / Oven');

      const c = ctx.canvas;

      // Plot log10 pressure over time (simple gauge)
      const p = lab.pressure;
      const logp = Math.log10(p);
      const lo = -12, hi = -8;
      const x = map(clamp(logp, lo, hi), lo, hi, 20, c.width-20);

      ctx.save();
      ctx.strokeStyle = 'rgba(255,255,255,.22)';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(20, c.height*0.55);
      ctx.lineTo(c.width-20, c.height*0.55);
      ctx.stroke();

      // tick labels
      ctx.fillStyle = 'rgba(255,255,255,.55)';
      ctx.font = `12px ${getComputedStyle(document.body).fontFamily}`;
      for(let L=-12; L<=-8; L++){
        const xx = map(L, lo, hi, 20, c.width-20);
        ctx.globalAlpha = 0.55;
        ctx.beginPath();
        ctx.moveTo(xx, c.height*0.55-8);
        ctx.lineTo(xx, c.height*0.55+8);
        ctx.stroke();
        ctx.globalAlpha = 0.9;
        ctx.fillText(`1e${L}`, xx-14, c.height*0.55+26);
      }

      // pointer
      const col = (p < 3e-11) ? 'var(--ok)' : (p < 2e-10) ? 'var(--warn)' : 'var(--bad)';
      ctx.strokeStyle = col;
      ctx.lineWidth = 4;
      ctx.beginPath();
      ctx.moveTo(x, c.height*0.55-18);
      ctx.lineTo(x, c.height*0.55+18);
      ctx.stroke();

      // oven bar
      const temp = lab.ovenTempC;
      const t0 = 20, t1 = 700;
      const frac = clamp((temp - t0)/(t1-t0), 0, 1);
      const barW = (c.width-40)*frac;
      ctx.fillStyle = 'rgba(255,210,123,.20)';
      ctx.fillRect(20, c.height*0.74, barW, 10);
      ctx.strokeStyle = 'rgba(255,255,255,.15)';
      ctx.strokeRect(20, c.height*0.74, c.width-40, 10);
      ctx.fillStyle = 'rgba(255,255,255,.65)';
      ctx.fillText(`Oven ${temp.toFixed(0)} °C`, 20, c.height*0.74-6);

      ctx.restore();
    }

    function drawIons(){
      const ctx = ensureCanvas(ui.cvIons);
      if(!ctx) return;
      clear(ctx);
      axes(ctx, 'Ion Chain');

      const c = ctx.canvas;
      const ions = lab.ions || [];
      const n = ions.length;

      const y = c.height*0.55;
      const left = 30, right = c.width-30;
      ctx.save();
      ctx.strokeStyle = 'rgba(255,255,255,.16)';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(left, y);
      ctx.lineTo(right, y);
      ctx.stroke();

      if(n === 0){
        ctx.fillStyle = 'rgba(255,255,255,.55)';
        ctx.font = `14px ${getComputedStyle(document.body).fontFamily}`;
        ctx.fillText('No ions loaded.', left, y-18);
        ctx.restore();
        return;
      }

      for(let i=0;i<n;i++){
        const x = map(i, 0, Math.max(1,n-1), left, right);
        // brightness proxy ~ exp(-nbar)
        const b = Math.exp(-lab.nbar/6);
        const r = 10;
        ctx.beginPath();
        ctx.fillStyle = `rgba(47,227,154,${0.25 + 0.55*b})`;
        ctx.arc(x,y,r,0,Math.PI*2);
        ctx.fill();
        ctx.strokeStyle = 'rgba(255,255,255,.12)';
        ctx.stroke();

        ctx.fillStyle = 'rgba(255,255,255,.65)';
        ctx.font = `12px ${getComputedStyle(document.body).fontFamily}`;
        ctx.fillText(`${i}`, x-3, y+28);
      }

      ctx.restore();
    }

    function drawPulseTimeline(ops){
      const ctx = ensureCanvas(ui.cvPulse);
      if(!ctx) return;
      clear(ctx);
      axes(ctx, 'Pulse Timeline');

      const c = ctx.canvas;
      ctx.save();

      if(!ops || ops.length === 0){
        ctx.fillStyle = 'rgba(255,255,255,.55)';
        ctx.font = `14px ${getComputedStyle(document.body).fontFamily}`;
        ctx.fillText('No compiled program.', 12, 50);
        ctx.restore();
        return;
      }

      const total = ops.reduce((s,o)=>s+o.dur,0);
      const x0 = 20, x1 = c.width-20;
      const y0 = 55, h = c.height-70;
      let t = 0;

      for(const o of ops){
        const a = t/total;
        const b = (t+o.dur)/total;
        const xx0 = map(a,0,1,x0,x1);
        const xx1 = map(b,0,1,x0,x1);

        const op = o.op;
        const isRead = op === 'readout';
        const isCool = (op==='doppler' || op==='opticalpump');
        const isGate = (op==='pi' || op==='pi/2' || op==='ms' || op==='rabi');
        const col = isRead ? 'rgba(123,221,255,.35)' : isCool ? 'rgba(255,210,123,.22)' : isGate ? 'rgba(47,227,154,.22)' : 'rgba(255,255,255,.12)';

        ctx.fillStyle = col;
        ctx.fillRect(xx0, y0, Math.max(1, xx1-xx0), h);

        ctx.strokeStyle = 'rgba(255,255,255,.12)';
        ctx.strokeRect(xx0, y0, Math.max(1, xx1-xx0), h);

        ctx.save();
        ctx.translate((xx0+xx1)/2, y0 + h/2);
        ctx.rotate(-Math.PI/2);
        ctx.fillStyle = 'rgba(255,255,255,.78)';
        ctx.font = `12px ${getComputedStyle(document.body).fontFamily}`;
        ctx.textAlign = 'center';
        ctx.fillText(o.raw, 0, 4);
        ctx.restore();

        t += o.dur;
      }

      ctx.fillStyle = 'rgba(255,255,255,.65)';
      ctx.font = `12px ${getComputedStyle(document.body).fontFamily}`;
      ctx.fillText(`Total ${(total*1e3).toFixed(2)} ms`, 20, c.height-14);

      ctx.restore();
    }

    function drawReadout(brightCounts, darkCounts){
      const ctx = ensureCanvas(ui.cvReadout);
      if(!ctx) return;

      clear(ctx);
      axes(ctx, 'Readout Histogram');

      const c = ctx.canvas;
      ctx.save();

      // update SPAM text
      if(lab.readout.lastSpam != null){
        ui.txtSpam.textContent = `${(lab.readout.lastSpam*100).toFixed(2)}%`;
      }else{
        ui.txtSpam.textContent = '—';
      }

      const detT = ui.numDetT.valueAsNumber || 200;
      const muB = (ui.numBright.valueAsNumber || 26) * (detT/200);
      const muD = (ui.numDark.valueAsNumber || 3) * (detT/200);
      const thr = ui.numThresh.valueAsNumber || 12;
      ui.txtCountsPhysical.innerHTML = `Pois(μ<sub>b</sub>≈${muB.toFixed(1)}), Pois(μ<sub>d</sub>≈${muD.toFixed(1)}), thr=${thr}`;

      if(!brightCounts?.length && !darkCounts?.length){
        ctx.fillStyle = 'rgba(255,255,255,.55)';
        ctx.font = `14px ${getComputedStyle(document.body).fontFamily}`;
        ctx.fillText('Run shots to populate histogram.', 12, 52);
        ctx.restore();
        return;
      }

      const all = brightCounts.concat(darkCounts);
      const maxC = Math.max(10, ...all);
      const bins = Math.min(40, Math.max(12, Math.floor(c.width/24)));
      const binW = maxC / bins;

      function hist(arr){
        const h = new Array(bins).fill(0);
        for(const k of arr){
          const i = Math.min(bins-1, Math.floor(k/binW));
          h[i]++;
        }
        return h;
      }

      const hb = hist(brightCounts);
      const hd = hist(darkCounts);
      const ymax = Math.max(1, ...hb, ...hd);

      const px0 = 20, px1 = c.width-20;
      const py0 = 48, py1 = c.height-20;

      // threshold line
      const tx = map(thr, 0, maxC, px0, px1);
      ctx.strokeStyle = 'rgba(255,255,255,.35)';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(tx, py0);
      ctx.lineTo(tx, py1);
      ctx.stroke();

      // draw bars
      for(let i=0;i<bins;i++){
        const x0 = map(i, 0, bins, px0, px1);
        const x1 = map(i+1, 0, bins, px0, px1);
        const yb = map(hb[i], 0, ymax, py1, py0);
        const yd = map(hd[i], 0, ymax, py1, py0);

        // dark (red-ish)
        ctx.fillStyle = 'rgba(255,107,107,.35)';
        ctx.fillRect(x0, yd, Math.max(1, x1-x0-1), py1-yd);

        // bright (green-ish)
        ctx.fillStyle = 'rgba(47,227,154,.30)';
        ctx.fillRect(x0, yb, Math.max(1, x1-x0-1), py1-yb);
      }

      ctx.fillStyle = 'rgba(255,255,255,.65)';
      ctx.font = `12px ${getComputedStyle(document.body).fontFamily}`;
      ctx.fillText('dark', 24, 42);
      ctx.fillText('bright', 70, 42);

      ctx.restore();
    }

    function drawDist(outcomes){
      const ctx = ensureCanvas(ui.cvDist);
      if(!ctx) return;

      clear(ctx);
      axes(ctx, 'Outcome Distribution');

      const c = ctx.canvas;
      ctx.save();

      if(!outcomes || outcomes.length === 0){
        ctx.fillStyle = 'rgba(255,255,255,.55)';
        ctx.font = `14px ${getComputedStyle(document.body).fontFamily}`;
        ctx.fillText('Run shots to populate distribution.', 12, 52);
        ctx.restore();
        return;
      }

      const top = outcomes.slice(0, Math.min(16, outcomes.length));
      const ymax = Math.max(...top.map(o=>o.p));
      const px0 = 20, px1 = c.width-20;
      const py0 = 48, py1 = c.height-20;

      for(let i=0;i<top.length;i++){
        const o = top[i];
        const x0 = map(i, 0, top.length, px0, px1);
        const x1 = map(i+1, 0, top.length, px0, px1);
        const y = map(o.p, 0, ymax, py1, py0);

        ctx.fillStyle = 'rgba(123,221,255,.30)';
        ctx.fillRect(x0, y, Math.max(2, x1-x0-2), py1-y);

        ctx.fillStyle = 'rgba(255,255,255,.75)';
        ctx.font = `12px ${getComputedStyle(document.body).fontFamily}`;
        ctx.save();
        ctx.translate((x0+x1)/2, py1+14);
        ctx.rotate(-Math.PI/6);
        ctx.textAlign = 'center';
        ctx.fillText(o.bits, 0, 0);
        ctx.restore();
      }

      ctx.fillStyle = 'rgba(255,255,255,.65)';
      ctx.font = `12px ${getComputedStyle(document.body).fontFamily}`;
      ctx.fillText(`Top ${top.length}`, 20, 42);

      ctx.restore();
    }

    function drawCamera(){
      const ctx = ensureCanvas(ui.cvCam);
      if(!ctx) return;

      clear(ctx);
      axes(ctx, 'Camera');

      const c = ctx.canvas;
      ctx.save();

      const img = lab.cam.lastImage;
      if(!img){
        ctx.fillStyle = 'rgba(255,255,255,.55)';
        ctx.font = `14px ${getComputedStyle(document.body).fontFamily}`;
        ctx.fillText('Run with Sensor=Camera to render a frame.', 12, 52);
        ctx.restore();
        return;
      }

      const w = c.width, h = c.height;
      // normalize to 0..255
      let vmax = 0;
      for(let i=0;i<img.length;i++) vmax = Math.max(vmax, img[i]);
      vmax = Math.max(1, vmax);

      const imageData = ctx.createImageData(w,h);
      for(let i=0;i<w*h;i++){
        const v = Math.floor(255 * clamp(img[i]/vmax, 0, 1));
        imageData.data[4*i+0] = v;
        imageData.data[4*i+1] = v;
        imageData.data[4*i+2] = v;
        imageData.data[4*i+3] = 255;
      }
      ctx.putImageData(imageData, 0, 0);

      // overlays
      const cx = w*0.5;
      const cy = h*0.52;
      const roiHalf = Math.max(4, lab.cam.roiHalf|0);

      if(lab.cam.overlay === 'roi'){
        ctx.strokeStyle = 'rgba(255,255,255,.55)';
        ctx.lineWidth = 2;
        ctx.strokeRect(cx-roiHalf, cy-roiHalf, 2*roiHalf, 2*roiHalf);
      }
      if(lab.cam.overlay === 'centroid' && lab.cam.centroid){
        const p = lab.cam.centroid;
        ctx.strokeStyle = 'rgba(47,227,154,.85)';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(p.x-10, p.y);
        ctx.lineTo(p.x+10, p.y);
        ctx.moveTo(p.x, p.y-10);
        ctx.lineTo(p.x, p.y+10);
        ctx.stroke();
      }

      ctx.restore();
    }

    function drawLaserDiag(){
      const ctx = ensureCanvas(ui.cvLaser);
      if(!ctx) return;
      clear(ctx);
      axes(ctx, 'Laser Error (arb)');

      const c = ctx.canvas;
      const keys = ['L369','L399','L935','L355','L638'];
      const errs = keys.map(k=> lab.lasers[k].err);
      const ymax = Math.max(1e-6, ...errs.map(e=>Math.abs(e)));

      const px0=20, px1=c.width-20;
      const py0=48, py1=c.height-18;

      ctx.save();
      for(let i=0;i<keys.length;i++){
        const k = keys[i];
        const e = lab.lasers[k].err;
        const x0 = map(i,0,keys.length,px0,px1);
        const x1 = map(i+1,0,keys.length,px0,px1);
        const yMid = (py0+py1)/2;
        const y = map(e, -ymax, ymax, py1, py0);

        // axis
        ctx.strokeStyle = 'rgba(255,255,255,.12)';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(x0+6, yMid);
        ctx.lineTo(x1-6, yMid);
        ctx.stroke();

        // bar from mid to y
        ctx.strokeStyle = lab.lasers[k].lock ? 'rgba(47,227,154,.8)' : 'rgba(255,107,107,.85)';
        ctx.lineWidth = 6;
        ctx.beginPath();
        ctx.moveTo((x0+x1)/2, yMid);
        ctx.lineTo((x0+x1)/2, y);
        ctx.stroke();

        ctx.fillStyle='rgba(255,255,255,.75)';
        ctx.font = `12px ${getComputedStyle(document.body).fontFamily}`;
        ctx.textAlign='center';
        ctx.fillText(k.replace('L',''), (x0+x1)/2, py1+14);
      }
      ctx.restore();
    }

    function drawMM(){
      const ctx = ensureCanvas(ui.cvMM);
      if(!ctx) return;
      clear(ctx);
      axes(ctx, 'Micromotion Sideband');

      const c = ctx.canvas;
      ctx.save();

      // show simple curve ratio vs comp distance from optimum (0,0)
      const xOpt=0, yOpt=0;
      const dx = lab.mm.compX - xOpt;
      const dy = lab.mm.compY - yOpt;
      const r = Math.sqrt(dx*dx + dy*dy);

      // amplitude increases with r
      lab.mm.amp = 0.10 + 0.85*(1 - Math.exp(-r*r/0.20));
      lab.mm.ratio = 0.02 + 0.60*(1 - Math.exp(-r*r/0.15));

      ui.txtMMamp.textContent = lab.mm.amp.toFixed(3);
      ui.txtMMratio.textContent = lab.mm.ratio.toFixed(3);

      const px0=20, px1=c.width-20;
      const py0=50, py1=c.height-18;

      // draw ratio bar
      const frac = clamp(lab.mm.ratio,0,1);
      const w = (px1-px0)*frac;
      ctx.fillStyle='rgba(255,210,123,.25)';
      ctx.fillRect(px0, (py0+py1)/2-8, w, 16);
      ctx.strokeStyle='rgba(255,255,255,.15)';
      ctx.strokeRect(px0, (py0+py1)/2-8, (px1-px0), 16);

      ctx.fillStyle='rgba(255,255,255,.70)';
      ctx.font = `12px ${getComputedStyle(document.body).fontFamily}`;
      ctx.fillText(`SB ratio ≈ ${(lab.mm.ratio*100).toFixed(1)}%`, px0, py0+10);

      ctx.restore();
    }

    function drawCalibration(){
      const ctx = ensureCanvas(ui.cvCal);
      if(!ctx) return;
      clear(ctx);
      axes(ctx, 'Calibration Plot');

      const c = ctx.canvas;
      ctx.save();

      const pts = lab.cal.points || [];
      if(pts.length === 0){
        ctx.fillStyle = 'rgba(255,255,255,.55)';
        ctx.font = `14px ${getComputedStyle(document.body).fontFamily}`;
        ctx.fillText('No calibration data.', 12, 52);
        ctx.restore();
        return;
      }

      const xs = pts.map(p=>p.x);
      const ys = pts.map(p=>p.y);
      const xmin = Math.min(...xs), xmax = Math.max(...xs);
      const ymin = Math.min(...ys), ymax = Math.max(...ys);

      const px0=30, px1=c.width-20;
      const py0=50, py1=c.height-20;

      // axes
      ctx.strokeStyle='rgba(255,255,255,.15)';
      ctx.lineWidth=2;
      ctx.beginPath();
      ctx.moveTo(px0, py1);
      ctx.lineTo(px1, py1);
      ctx.moveTo(px0, py1);
      ctx.lineTo(px0, py0);
      ctx.stroke();

      // points
      ctx.fillStyle='rgba(123,221,255,.85)';
      for(const p of pts){
        const x = map(p.x, xmin, xmax, px0, px1);
        const y = map(p.y, ymin, ymax, py1, py0);
        ctx.beginPath();
        ctx.arc(x,y,4,0,Math.PI*2);
        ctx.fill();
      }

      ctx.fillStyle='rgba(255,255,255,.65)';
      ctx.font = `12px ${getComputedStyle(document.body).fontFamily}`;
      ctx.fillText(`n=${pts.length}`, px0, py0+12);

      ctx.restore();
    }

    function drawPhotonTrace(){
      const ctx = ensureCanvas(ui.cvPhoton);
      if(!ctx) return;
      clear(ctx);
      axes(ctx, 'Photon Trace (toy)');

      const c = ctx.canvas;
      ctx.save();

      // draw a rolling squiggle based on pressure + nbar
      const px0=20, px1=c.width-20;
      const py0=48, py1=c.height-20;

      const N=200;
      ctx.strokeStyle='rgba(123,221,255,.55)';
      ctx.lineWidth=2;

      ctx.beginPath();
      for(let i=0;i<N;i++){
        const x = map(i,0,N-1,px0,px1);
        const t = lab.t + i*0.02;
        const p = Math.log10(lab.pressure);
        const yBase = 0.55 + 0.18*Math.sin(2*Math.PI*0.22*t) + 0.10*Math.sin(2*Math.PI*0.07*t + 1.4);
        const yNoise = (0.06 + 0.02*lab.nbar) * randn() * 0.12;
        const y = clamp(yBase + yNoise + 0.04*(p+10), 0.08, 0.92);
        const yy = map(y,0,1,py1,py0);
        if(i===0) ctx.moveTo(x,yy); else ctx.lineTo(x,yy);
      }
      ctx.stroke();

      ctx.fillStyle='rgba(255,255,255,.65)';
      ctx.font = `12px ${getComputedStyle(document.body).fontFamily}`;
      ctx.fillText(`pressure=${lab.pressure.toExponential(2)} mbar`, px0, py0+12);

      ctx.restore();
    }

    /********************
     * Tables
     ********************/
    function renderDistributionTable(outcomes){
      ui.tblOut.innerHTML = '';
      const top = outcomes.slice(0, 10);
      for(const o of top){
        const tr = document.createElement('tr');
        const tdBits = document.createElement('td');
        const tdP = document.createElement('td');
        const tdN = document.createElement('td');
        tdBits.textContent = o.bits;
        tdP.textContent = o.p.toFixed(4);
        tdN.textContent = o.c.toString();
        tr.appendChild(tdBits);
        tr.appendChild(tdP);
        tr.appendChild(tdN);
        ui.tblOut.appendChild(tr);
      }
    }

    function setCalRows(rows){
      ui.tblCal.innerHTML = '';
      for(const r of rows){
        const tr = document.createElement('tr');
        for(const key of ['type','x','y','note']){
          const td = document.createElement('td');
          td.textContent = (r[key] ?? '').toString();
          tr.appendChild(td);
        }
        ui.tblCal.appendChild(tr);
      }
    }

    /********************
     * UI bindings
     ********************/
    function setReady(ok, msg){
      ui.dotReady.style.background = ok ? 'var(--ok)' : 'var(--warn)';
      ui.dotReady.style.boxShadow = ok ? '0 0 10px rgba(47,227,154,.35)' : '0 0 10px rgba(255,210,123,.35)';
      ui.readyTxt.textContent = msg;
    }

    function syncText(){
      ui.txtPump.textContent = String(Math.round(lab.pumpSpeed*100));
      ui.txtOvenSet.textContent = String(Math.round(lab.ovenSet*100));
      ui.txtLLR.textContent = (ui.rngLLR.valueAsNumber || 0).toFixed(1);
      ui.txtCamGain.textContent = (lab.cam.gain).toFixed(1);
      ui.txtCamSigma.textContent = (lab.cam.sigma).toFixed(1);

      ui.kvPressure.textContent = `${lab.pressure.toExponential(2)} mbar`;
      ui.kvOven.textContent = `${lab.ovenTempC.toFixed(0)} °C`;
      ui.kvRF.textContent = `${lab.rf.fMHz.toFixed(1)} MHz @ ${lab.rf.vpp.toFixed(0)} Vpp`;
      ui.kvWz.textContent = `${estimateWz().toFixed(2)} MHz`;
      ui.kvIons.textContent = `${lab.ionsLoaded}`;
      ui.kvNbar.textContent = `${lab.nbar.toFixed(2)}`;
    }

    function laserStep(dt){
      // random walk error, pulled to 0 if locked
      const keys = ['L369','L399','L935','L355','L638'];
      for(const k of keys){
        const L = lab.lasers[k];
        const walk = 0.10 * randn() * Math.sqrt(dt);
        L.err += walk;
        const pull = L.lock ? 1.5 : 0.10;
        L.err += (-L.err) * (1 - Math.exp(-pull*dt));
        // occasional lock loss if unlocked
        if(!L.lock && Math.random() < 0.02*dt){
          // stay unlocked; bigger drift
          L.err += 0.6*randn();
        }
      }

      // UI text + sparks
      function upd(k, txt, sp){
        const L = lab.lasers[k];
        txt.textContent = `${L.err.toFixed(3)}`;
        const a = Math.abs(L.err);
        const ok = L.lock && a < 0.35;
        const warn = L.lock && a >= 0.35 && a < 0.8;
        const bad = !L.lock || a >= 0.8;
        sp.classList.toggle('ok', ok);
        sp.classList.toggle('warn', warn);
        sp.classList.toggle('bad', bad);
      }
      upd('L369', ui.txtL369Err, ui.spL369);
      upd('L399', ui.txtL399Err, ui.spL399);
      upd('L935', ui.txtL935Err, ui.spL935);
      upd('L355', ui.txtL355Err, ui.spL355);
      upd('L638', ui.txtL638Err, ui.spL638);
    }

    function bindControls(){
      // sliders
      ui.rngPump.addEventListener('input', () => { lab.pumpSpeed = ui.rngPump.valueAsNumber/100; syncText(); });
      ui.rngOven.addEventListener('input', () => { lab.ovenSet = ui.rngOven.valueAsNumber/100; syncText(); });

      // trap numbers
      function syncTrap(){
        lab.rf.fMHz = ui.numRFf.valueAsNumber || lab.rf.fMHz;
        lab.rf.vpp = ui.numRFv.valueAsNumber || lab.rf.vpp;
        lab.trap.wzMHz = ui.numWz.valueAsNumber || lab.trap.wzMHz;
        lab.trap.wrMHz = ui.numWr.valueAsNumber || lab.trap.wrMHz;
        lab.trap.BmT = ui.numB.valueAsNumber || lab.trap.BmT;
        syncText();
      }
      [ui.numRFf, ui.numRFv, ui.numWz, ui.numWr, ui.numB].forEach(el => el.addEventListener('input', syncTrap));

      // readout
      ui.rngLLR.addEventListener('input', ()=>{ ui.txtLLR.textContent = (ui.rngLLR.valueAsNumber||0).toFixed(1); });

      // camera
      ui.selCamMode.addEventListener('change', ()=>{ lab.cam.mode = ui.selCamMode.value; });
      ui.rngCamGain.addEventListener('input', ()=>{ lab.cam.gain = ui.rngCamGain.valueAsNumber; ui.txtCamGain.textContent = lab.cam.gain.toFixed(1); });
      ui.rngCamSigma.addEventListener('input', ()=>{ lab.cam.sigma = ui.rngCamSigma.valueAsNumber; ui.txtCamSigma.textContent = lab.cam.sigma.toFixed(1); });
      ui.numCamScale.addEventListener('input', ()=>{ lab.cam.scaleUmPerPx = ui.numCamScale.valueAsNumber || 1.2; });
      ui.numCamROI.addEventListener('input', ()=>{ lab.cam.roiHalf = ui.numCamROI.valueAsNumber || 14; });
      ui.selCamOverlay.addEventListener('change', ()=>{ lab.cam.overlay = ui.selCamOverlay.value; });

      // vacuum buttons
      ui.btnPump.addEventListener('click', ()=>{ lab.pumpOn = !lab.pumpOn; log(`Pump ${lab.pumpOn?'ON':'OFF'}`); });
      ui.btnBake.addEventListener('click', ()=>{ lab.bakeOn = !lab.bakeOn; log(`Bake ${lab.bakeOn?'ON':'OFF'}`); });
      ui.btnOven.addEventListener('click', ()=>{ lab.ovenOn = !lab.ovenOn; log(`Oven ${lab.ovenOn?'ON':'OFF'}`); });
      ui.btnLoad.addEventListener('click', ()=>{
        const n = clamp(ui.numQ.valueAsNumber || 4, 1, 16)|0;
        lab.ionsLoaded = n;
        lab.ions = makeIonChain(n);
        log(`Loaded ion chain: N=${n}`);
      });
      ui.btnCool.addEventListener('click', ()=>{
        lab.coolingOn = !lab.coolingOn;
        log(`Cooling ${lab.coolingOn?'ON':'OFF'}`);
      });
      ui.btnReset.addEventListener('click', ()=>{
        Object.assign(lab, {
          pressure: 1e-9,
          ovenTempC: 25,
          ionsLoaded: 0,
          ions: [],
          nbar: 8.0,
          readout: { lastBrightCounts:[], lastDarkCounts:[], lastSpam:null },
          cal: { points:[], tableRows:[] },
          cam: { ...lab.cam, lastImage:null, lastCounts:null, centroid:null },
        });
        ui.tblOut.innerHTML = '';
        ui.tblCal.innerHTML = '';
        log('Reset.');
      });

      // program templates
      ui.selTemplate.addEventListener('change', ()=>{
        ui.txtProgram.value = templates[ui.selTemplate.value] || '';
      });

      ui.btnCompile.addEventListener('click', ()=>{
        try{
          const text = ui.txtProgram.value || '';
          const ops = compileProgram(text);
          lab.program.text = text;
          lab.program.compiled = ops;
          lab.program.lastError = null;
          drawPulseTimeline(ops);
          setReady(true, 'COMPILED');
          log(`Compiled ${ops.length} ops.`);
        }catch(e){
          lab.program.lastError = e;
          setReady(false, 'ERROR');
          log(`Compile error: ${e.message}`);
        }
      });

      ui.btnRun.addEventListener('click', ()=>{
        try{
          // compile if needed
          const text = ui.txtProgram.value || '';
          const ops = compileProgram(text);
          lab.program.text = text;
          lab.program.compiled = ops;
          lab.program.lastError = null;

          // run
          runShots(ops);
          setReady(true, 'RAN');
        }catch(e){
          setReady(false, 'ERROR');
          log(`Run error: ${e.message}`);
        }
      });

      // lasers
      function syncLocks(){
        lab.lasers.L369.lock = ui.chkL369.checked;
        lab.lasers.L399.lock = ui.chkL399.checked;
        lab.lasers.L935.lock = ui.chkL935.checked;
        lab.lasers.L355.lock = ui.chkL355.checked;
        lab.lasers.L638.lock = ui.chkL638.checked;
      }
      [ui.chkL369,ui.chkL399,ui.chkL935,ui.chkL355,ui.chkL638].forEach(el=>el.addEventListener('change', ()=>{ syncLocks(); }));

      ui.btnLockAll.addEventListener('click', ()=>{
        [ui.chkL369,ui.chkL399,ui.chkL935,ui.chkL355,ui.chkL638].forEach(el=>el.checked=true);
        syncLocks();
        log('Lasers: lock all.');
      });
      ui.btnUnlockAll.addEventListener('click', ()=>{
        [ui.chkL369,ui.chkL399,ui.chkL935,ui.chkL355,ui.chkL638].forEach(el=>el.checked=false);
        syncLocks();
        log('Lasers: unlock all.');
      });
      ui.btnKickLasers.addEventListener('click', ()=>{
        for(const k of ['L369','L399','L935','L355','L638']){
          lab.lasers[k].err += 0.9*randn();
        }
        log('Lasers: kick.');
      });

      // micromotion
      function syncMM(){
        lab.mm.compX = ui.numCompX.valueAsNumber || 0;
        lab.mm.compY = ui.numCompY.valueAsNumber || 0;
      }
      ui.numCompX.addEventListener('input', syncMM);
      ui.numCompY.addEventListener('input', syncMM);
      ui.btnAutoMM.addEventListener('click', ()=>{
        // simple gradient-ish step toward 0
        lab.mm.compX *= 0.55;
        lab.mm.compY *= 0.55;
        ui.numCompX.value = lab.mm.compX.toFixed(2);
        ui.numCompY.value = lab.mm.compY.toFixed(2);
        log('Micromotion: auto step toward optimum.');
      });

      // base select
      ui.selBaseP.addEventListener('change', ()=>{ lab.baseP = parseFloat(ui.selBaseP.value); });

      // camera overlay init
      lab.cam.overlay = ui.selCamOverlay.value;

      // init template text
      ui.txtProgram.value = templates[ui.selTemplate.value] || templates.ramsey;
      syncLocks();
      syncTrap();
      syncMM();
      syncText();
    }

    /********************
     * Main loop
     ********************/
    function tick(){
      const t = nowMs();
      const dt = Math.min(0.05, (t - lab.last)/1000);
      lab.last = t;
      lab.t += dt;

      pressureUpdate(dt);
      ovenUpdate(dt);
      ionsUpdate(dt);
      laserStep(dt);

      // update ready status based on "reasonable" conditions
      const okVac = lab.pressure < 2.5e-10;
      const okIons = lab.ionsLoaded > 0;
      if(okVac && okIons) setReady(true, 'READY');
      else setReady(false, okVac ? 'NO IONS' : 'VAC');

      syncText();

      // draw
      drawVacuum();
      drawIons();
      drawPulseTimeline(lab.program.compiled);
      drawReadout(lab.readout.lastBrightCounts, lab.readout.lastDarkCounts);
      drawCamera();
      drawPhotonTrace();
      drawLaserDiag();
      drawMM();
      drawCalibration();

      requestAnimationFrame(tick);
    }

    // Resize handler
    window.addEventListener('resize', ()=>{
      [
        ui.cvEnv, ui.cvIons, ui.cvPulse, ui.cvReadout, ui.cvDist, ui.cvCam,
        ui.cvPhoton, ui.cvMS, ui.cvLaser, ui.cvMM, ui.cvCal
      ].forEach(ensureCanvas);
    });

    // Boot
    bindControls();
    log('Simulator ready.');
    requestAnimationFrame(tick);
  </script>
</body>
</html>
