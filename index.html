<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Quantum Ion Lab Simulator</title>
  <style>
    :root{
      --bg:#0b0f14;
      --bg2:#070a0f;
      --panel:rgba(255,255,255,.05);
      --panel2:rgba(255,255,255,.035);
      --stroke:rgba(255,255,255,.10);
      --stroke2:rgba(255,255,255,.18);
      --text:#e9f0fb;
      --muted:#a7b4c8;
      --faint:rgba(167,180,200,.65);

      --ok:#2fe39a;
      --warn:#ffd27b;
      --bad:#ff6b6b;
      --accent:#7bdcff;

      --shadow: 0 18px 48px rgba(0,0,0,.45);
      --shadow2: 0 10px 26px rgba(0,0,0,.30);
      --r:14px;

      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace;
      --sans: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    }

    *{ box-sizing:border-box; }
    html,body{ height:100%; }
    body{
      margin:0;
      color:var(--text);
      font-family:var(--sans);
      letter-spacing:.1px;
      background:
        radial-gradient(1100px 700px at 18% -10%, rgba(123,220,255,.14), transparent 55%),
        radial-gradient(900px 520px at 78% 0%, rgba(47,227,154,.10), transparent 60%),
        radial-gradient(900px 520px at 55% 120%, rgba(180,160,255,.08), transparent 60%),
        linear-gradient(180deg, var(--bg2), var(--bg));
      overflow-x:hidden;
    }

    /* ---------- App bar ---------- */
    .appbar{
      position:sticky; top:0; z-index:50;
      display:grid;
      grid-template-columns: auto 1fr auto auto;
      gap:10px;
      align-items:center;
      padding:10px 12px;
      border-bottom:1px solid var(--stroke);
      background: rgba(11,15,20,.68);
      backdrop-filter: blur(10px);
    }
    .appbar .left{
      display:flex; align-items:center; gap:10px;
      min-width: 0;
    }
    .brand{
      min-width:0;
      display:flex; flex-direction:column; gap:2px;
    }
    .brand h1{
      margin:0;
      font-size:15px;
      font-weight:850;
      letter-spacing:.2px;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }
    .brand .sub{
      margin:0;
      font-size:12px;
      color:var(--muted);
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }
    .tag{
      display:inline-flex;
      align-items:center;
      gap:6px;
      border:1px solid rgba(123,220,255,.25);
      background: rgba(123,220,255,.08);
      color: rgba(200,245,255,.95);
      border-radius:999px;
      padding:2px 8px;
      font-size:11px;
      font-weight:750;
      margin-left:8px;
      vertical-align:middle;
    }
    .tag .dotMini{ width:7px; height:7px; border-radius:50%; background: rgba(123,220,255,.95); }

    .iconBtn{
      border:1px solid var(--stroke);
      background:rgba(255,255,255,.05);
      color:var(--text);
      border-radius:12px;
      padding:9px 10px;
      cursor:pointer;
      display:inline-flex;
      align-items:center;
      justify-content:center;
      box-shadow: var(--shadow2);
    }
    .iconBtn:hover{ background:rgba(255,255,255,.08); }
    .iconBtn:active{ transform:translateY(1px); }

    .search{
      display:flex; align-items:center; gap:8px;
      min-width: 260px;
      max-width: 520px;
    }
    .search input[type="search"]{
      width:100%;
      border-radius:12px;
      border:1px solid var(--stroke);
      background: rgba(0,0,0,.22);
      color:var(--text);
      padding:9px 10px;
      outline:none;
      box-shadow: inset 0 0 0 1px rgba(255,255,255,.02);
    }
    .search input[type="search"]::placeholder{ color: rgba(167,180,200,.65); }

    .actions{
      display:flex; gap:8px; align-items:center;
      flex-wrap:wrap;
      justify-content:flex-end;
    }

    .pill{
      border:1px solid var(--stroke);
      background:rgba(255,255,255,.04);
      border-radius:999px;
      padding:8px 10px;
      font-size:12px;
      color:var(--muted);
      display:flex;
      gap:10px;
      align-items:center;
      white-space:nowrap;
      box-shadow: var(--shadow2);
    }
    .dot{
      width:10px;height:10px;border-radius:50%;
      background:var(--warn);
      box-shadow:0 0 12px rgba(255,210,123,.35);
      flex:0 0 auto;
    }
    .pill strong{ color:var(--text); font-weight:850; letter-spacing:.2px; }

    /* ---------- Layout ---------- */
    .layout{
      display:grid;
      grid-template-columns: 270px minmax(0,1fr) 420px;
      gap:14px;
      padding:14px;
      max-width: 1680px;
      margin:0 auto;
      align-items:start;
    }

    /* ---------- Sidebar ---------- */
    .sidebar{
      border:1px solid var(--stroke);
      background: linear-gradient(180deg, rgba(255,255,255,.05), rgba(255,255,255,.03));
      border-radius: var(--r);
      box-shadow: var(--shadow);
      overflow:hidden;
      position: sticky;
      top: 70px;
      max-height: calc(100vh - 88px);
      display:flex;
      flex-direction:column;
    }
    .sideHead{
      padding:12px 12px 10px;
      border-bottom:1px solid var(--stroke);
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      background: rgba(255,255,255,.02);
    }
    .sideHead .t{
      font-weight:850;
      font-size:12px;
      letter-spacing:.2px;
      color: rgba(232,240,251,.92);
    }
    .sideBody{
      padding:10px;
      overflow:auto;
    }
    .sideSectionTitle{
      font-size:11px;
      color: rgba(167,180,200,.85);
      font-weight:850;
      letter-spacing:.16px;
      text-transform:uppercase;
      margin:10px 4px 8px;
    }
    .nav{
      display:flex;
      flex-direction:column;
      gap:6px;
    }
    .nav a{
      display:flex;
      gap:10px;
      align-items:center;
      padding:8px 10px;
      border-radius:12px;
      text-decoration:none;
      color: rgba(232,240,251,.86);
      border:1px solid transparent;
      background: transparent;
      font-size:12px;
      font-weight:700;
    }
    .nav a:hover{
      background: rgba(255,255,255,.05);
      border-color: rgba(255,255,255,.08);
    }
    .nav a.active{
      background: rgba(123,220,255,.11);
      border-color: rgba(123,220,255,.22);
      box-shadow: inset 0 0 0 1px rgba(123,220,255,.08);
    }
    .nav a .nDot{
      width:8px;height:8px;border-radius:50%;
      background: rgba(255,255,255,.18);
      box-shadow: 0 0 0 1px rgba(255,255,255,.10) inset;
      flex:0 0 auto;
    }
    .nav a.active .nDot{ background: rgba(123,220,255,.95); }

    .qaGrid{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:8px;
    }

    /* ---------- Main / Right ---------- */
    .main{
      min-width:0;
      display:flex;
      flex-direction:column;
      gap:14px;
    }
    .right{
      min-width:0;
      display:flex;
      flex-direction:column;
      gap:14px;
      position: sticky;
      top: 70px;
      max-height: calc(100vh - 88px);
      overflow:auto;
      padding-right:2px;
    }

    /* ---------- Sections & Panels ---------- */
    section[data-section]{
      scroll-margin-top: 84px;
    }
    .sectionHead{
      display:flex;
      align-items:flex-end;
      justify-content:space-between;
      gap:12px;
      padding:10px 2px 0;
    }
    .sectionHead h2{
      margin:0;
      font-size:13px;
      font-weight:900;
      letter-spacing:.24px;
    }
    .sectionHead .hint{
      margin:0;
      font-size:12px;
      color: var(--muted);
      line-height:1.25;
    }
    .sectionTools{
      display:flex;
      gap:8px;
      align-items:center;
      flex-wrap:wrap;
      justify-content:flex-end;
    }

    details.panel{
      border:1px solid var(--stroke);
      background: linear-gradient(180deg, rgba(255,255,255,.05), rgba(255,255,255,.03));
      border-radius: var(--r);
      box-shadow: var(--shadow);
      overflow:hidden;
    }
    details.panel > summary{
      list-style:none;
      cursor:pointer;
      user-select:none;
      padding:12px 12px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
      border-bottom:1px solid var(--stroke);
      background: rgba(255,255,255,.02);
    }
    details.panel > summary::-webkit-details-marker{ display:none; }
    .sumLeft{
      display:flex;
      flex-direction:column;
      gap:3px;
      min-width:0;
    }
    .sumTitle{
      font-size:12.5px;
      font-weight:900;
      letter-spacing:.2px;
      margin:0;
    }
    .sumSub{
      font-size:12px;
      color: var(--muted);
      margin:0;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }
    .chev{
      font-size:14px;
      color: rgba(232,240,251,.80);
      transform: rotate(0deg);
      transition: transform .15s ease;
      flex:0 0 auto;
    }
    details.panel[open] .chev{ transform: rotate(180deg); }

    .panelBody{
      padding:12px;
    }

    .grid2{ display:grid; grid-template-columns:1fr 1fr; gap:10px; }
    .grid3{ display:grid; grid-template-columns:1fr 1fr 1fr; gap:10px; }
    .row{ display:flex; gap:10px; align-items:center; }
    .wrapRow{ flex-wrap:wrap; }
    .stack{ display:flex; flex-direction:column; gap:10px; }
    .sep{ height:1px; background:var(--stroke); margin:10px 0; }

    label{
      display:flex;
      flex-direction:column;
      gap:6px;
      font-size:12px;
      color:var(--muted);
    }
    input[type="number"], input[type="text"], textarea, select{
      width:100%;
      border-radius:12px;
      border:1px solid var(--stroke);
      background:rgba(0,0,0,.22);
      color:var(--text);
      padding:9px 10px;
      outline:none;
      box-shadow: inset 0 0 0 1px rgba(255,255,255,.02);
    }
    input[type="range"]{ width:100%; }
    textarea{
      min-height:120px;
      resize:vertical;
      font-family:var(--mono);
      line-height:1.35;
      font-size:12px;
    }

    .btn{
      border:1px solid var(--stroke2);
      background:rgba(255,255,255,.05);
      color:var(--text);
      border-radius:12px;
      padding:9px 10px;
      cursor:pointer;
      font-weight:850;
      font-size:12px;
      box-shadow: var(--shadow2);
      display:inline-flex;
      align-items:center;
      justify-content:center;
      gap:8px;
    }
    .btn:hover{ background:rgba(255,255,255,.08); }
    .btn:active{ transform:translateY(1px); }
    .btn.primary{
      border-color: rgba(123,220,255,.35);
      background: rgba(123,220,255,.11);
      color: rgba(210,247,255,.98);
    }
    .btn.good{
      border-color: rgba(47,227,154,.35);
      background: rgba(47,227,154,.10);
      color: rgba(200,255,230,.98);
    }
    .btn.warn{
      border-color: rgba(255,210,123,.38);
      background: rgba(255,210,123,.10);
      color: rgba(255,236,200,.98);
    }
    .btn.danger{
      border-color: rgba(255,107,107,.40);
      background: rgba(255,107,107,.10);
      color: rgba(255,220,220,.98);
    }
    .btn.ghost{
      background: rgba(0,0,0,.10);
      border-color: rgba(255,255,255,.12);
      box-shadow:none;
    }
    .btn.toggle[aria-pressed="true"]{
      border-color: rgba(47,227,154,.45);
      background: rgba(47,227,154,.14);
    }

    .kv{
      display:grid;
      grid-template-columns: 1fr auto;
      gap:8px 10px;
      font-size:12px;
      color:var(--muted);
      align-items:center;
    }
    .kv .k{ color:var(--muted); }
    .kv .v{ font-family:var(--mono); color:var(--text); }

    .cards{
      display:grid;
      grid-template-columns: repeat(3, 1fr);
      gap:10px;
    }
    .card{
      border:1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.18);
      border-radius: 14px;
      padding:10px 10px;
      box-shadow: inset 0 0 0 1px rgba(255,255,255,.02);
    }
    .card .k{
      font-size:11px;
      color: rgba(167,180,200,.80);
      font-weight:850;
      letter-spacing:.18px;
      text-transform:uppercase;
    }
    .card .v{
      margin-top:6px;
      font-family: var(--mono);
      font-size:13px;
      color: rgba(232,240,251,.95);
      font-weight:850;
    }
    .card .s{
      margin-top:4px;
      font-size:11px;
      color: rgba(167,180,200,.72);
    }

    .spark{
      width:10px;height:10px;border-radius:50%;
      background:var(--warn);
      box-shadow:0 0 10px rgba(255,210,123,.25);
      border:1px solid rgba(255,255,255,.12);
      flex:0 0 auto;
    }
    .spark.ok{ background:var(--ok); box-shadow:0 0 10px rgba(47,227,154,.25); }
    .spark.warn{ background:var(--warn); box-shadow:0 0 10px rgba(255,210,123,.25); }
    .spark.bad{ background:var(--bad); box-shadow:0 0 10px rgba(255,107,107,.25); }

    .cv{
      width:100%;
      height:240px;
      display:block;
      border-radius:12px;
      border:1px solid var(--stroke);
      background:rgba(0,0,0,.18);
      box-shadow: inset 0 0 0 1px rgba(255,255,255,.02);
    }
    .cv.tall{ height:320px; }
    .cv.short{ height:180px; }
    .cv.mini{ height:160px; }

    table{
      width:100%;
      border-collapse:collapse;
      font-size:12px;
    }
    th,td{
      border-bottom:1px solid var(--stroke);
      padding:8px 6px;
      text-align:left;
    }
    th{ color:var(--muted); font-weight:900; }
    .mono{ font-family:var(--mono); }

    .logWrap{
      display:flex; flex-direction:column; gap:10px;
    }
    .logBar{
      display:flex; gap:8px; align-items:center; justify-content:space-between; flex-wrap:wrap;
    }
    .log{
      font-family:var(--mono);
      font-size:12px;
      line-height:1.35;
      color:var(--text);
      white-space:pre-wrap;
      margin:0;
      max-height:220px;
      overflow:auto;
      border-radius:12px;
      border:1px solid var(--stroke);
      background:rgba(0,0,0,.25);
      padding:10px;
    }

    /* ---------- Subtle tooltip (custom, not browser title) ---------- */
    .tt{
      position: fixed;
      top: 0;
      left: 0;
      transform: translate(-9999px, -9999px);
      opacity: 0;
      pointer-events: none; /* important: never block clicks */
      transition: opacity .12s ease;
      z-index: 90;

      max-width: min(360px, calc(100vw - 24px));
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(12,16,24,.92);
      backdrop-filter: blur(10px);
      color: rgba(232,240,251,.95);
      border-radius: 12px;
      padding: 8px 10px;
      box-shadow: var(--shadow2);
      font-size: 12px;
      line-height: 1.35;
    }
    .tt.show{ opacity: 1; }

    /* ---------- Toast ---------- */
    .toast{
      position: fixed;
      left: 50%;
      bottom: 18px;
      transform: translateX(-50%) translateY(8px);
      opacity: 0;
      pointer-events:none;
      transition: opacity .18s ease, transform .18s ease;
      z-index: 80;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(10,14,20,.78);
      backdrop-filter: blur(10px);
      color: rgba(232,240,251,.95);
      padding:10px 12px;
      border-radius: 14px;
      box-shadow: var(--shadow);
      max-width: min(720px, calc(100vw - 22px));
      font-size:12px;
    }
    .toast.show{ opacity: 1; transform: translateX(-50%) translateY(0); }

    /* ---------- Overlay / mobile nav ---------- */
    .overlay{
      position: fixed; inset: 0;
      background: rgba(0,0,0,.45);
      opacity: 0;
      pointer-events: none;
      transition: opacity .18s ease;
      z-index: 60;
    }
    body.navOpen .overlay{ opacity: 1; pointer-events: auto; }

    /* ---------- Dialog ---------- */
    dialog{
      border:none;
      border-radius: 18px;
      padding:0;
      width: min(720px, calc(100vw - 24px));
      background: rgba(16,22,32,.96);
      color: rgba(232,240,251,.95);
      box-shadow: var(--shadow);
    }
    dialog::backdrop{ background: rgba(0,0,0,.55); }
    .dlgHd{
      padding:14px 14px 10px;
      border-bottom:1px solid rgba(255,255,255,.10);
      display:flex; align-items:flex-start; justify-content:space-between; gap:10px;
    }
    .dlgHd h3{ margin:0; font-size:13px; font-weight:950; letter-spacing:.2px; }
    .dlgBd{
      padding:12px 14px 14px;
      color: rgba(167,180,200,.95);
      font-size:12px;
      line-height:1.45;
      max-height: min(72vh, 720px);
      overflow:auto;
    }
    .kbd{
      font-family: var(--mono);
      border:1px solid rgba(255,255,255,.16);
      background: rgba(0,0,0,.25);
      padding:2px 6px;
      border-radius:8px;
      color: rgba(232,240,251,.92);
    }
    .dlgFt{
      padding: 0 14px 14px;
      display:flex; justify-content:flex-end; gap:10px;
    }

    .manual h4{
      margin: 12px 0 6px;
      font-size: 12px;
      font-weight: 950;
      letter-spacing: .18px;
      color: rgba(232,240,251,.92);
      text-transform: uppercase;
    }
    .manual p{ margin: 6px 0; }
    .manual code{
      font-family: var(--mono);
      font-size: 11px;
      padding: 1px 5px;
      border-radius: 8px;
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(0,0,0,.22);
      color: rgba(232,240,251,.94);
    }
    .manual pre{
      margin: 8px 0 10px;
      padding: 10px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(0,0,0,.25);
      overflow:auto;
      font-family: var(--mono);
      font-size: 11.5px;
      line-height: 1.35;
      color: rgba(232,240,251,.92);
      white-space: pre;
    }
    .manual ol, .manual ul{ margin: 6px 0 8px; padding-left: 18px; }
    .manual li{ margin: 4px 0; }

    /* ---------- Focus ---------- */
    :focus-visible{
      outline: 2px solid rgba(123,220,255,.85);
      outline-offset: 2px;
      border-radius: 10px;
    }

    /* ---------- Responsive ---------- */
    @media (max-width: 1220px){
      .layout{ grid-template-columns: 270px minmax(0,1fr); }
      .right{ position: static; max-height: none; overflow: visible; }
    }
    @media (max-width: 980px){
      .appbar{ grid-template-columns: auto 1fr auto; }
      .search{ display:none; }
      .layout{ grid-template-columns: 1fr; }
      .sidebar{
        position: fixed;
        left: 12px;
        top: 62px;
        width: min(320px, calc(100vw - 24px));
        max-height: calc(100vh - 78px);
        transform: translateX(-120%);
        transition: transform .18s ease;
        z-index: 70;
      }
      body.navOpen .sidebar{ transform: translateX(0); }
      .right{ position: static; max-height:none; }
      .cards{ grid-template-columns: 1fr; }
    }
    @media (prefers-reduced-motion: reduce){
      *{ transition: none !important; scroll-behavior: auto !important; }
    }
    html{ scroll-behavior: smooth; }
  </style>
</head>

<body>
  <div class="appbar" role="banner">
    <div class="left">
      <button id="btnNav" class="iconBtn" type="button" aria-label="Open navigation">
        ☰
      </button>
      <div class="brand">
        <h1>
          Quantum Ion Lab Simulator
          <span class="tag"><span class="dotMini" aria-hidden="true"></span>single-file</span>
        </h1>
        <p class="sub">Vacuum → load → program → shots → readout (with lasers, micromotion, camera)</p>
      </div>
    </div>

    <div class="search" aria-label="Filter panels">
      <input id="txtFilter" type="search" placeholder="Filter panels / controls (e.g., “T2”, “laser”, “readout”)…" />
    </div>

    <div class="actions">
      <button id="btnCompileTop" class="btn primary" type="button">Compile</button>
      <button id="btnRunTop" class="btn good" type="button">Run</button>
      <button id="btnTips" class="btn ghost toggle" type="button" aria-pressed="true">Tooltips</button>
      <button id="btnHelp" class="btn ghost" type="button">Help</button>
    </div>

    <div class="pill" aria-live="polite">
      <span id="dotReady" class="dot" aria-hidden="true"></span>
      <strong id="readyTxt">INIT</strong>
    </div>
  </div>

  <div id="navOverlay" class="overlay" aria-hidden="true"></div>

  <div class="layout">
    <!-- SIDEBAR -->
    <aside id="sidebar" class="sidebar" aria-label="Navigation sidebar">
      <div class="sideHead">
        <div class="t">Navigation</div>
        <button id="btnCloseNav" class="btn ghost" type="button" style="padding:7px 10px; border-radius:12px;">Close</button>
      </div>
      <div class="sideBody">
        <div class="sideSectionTitle">Jump to</div>
        <nav id="nav" class="nav">
          <a href="#section-overview"><span class="nDot"></span>Overview</a>
          <a href="#section-setup"><span class="nDot"></span>Setup (vacuum / trap)</a>
          <a href="#section-program"><span class="nDot"></span>Program (compile / timeline)</a>
          <a href="#section-run"><span class="nDot"></span>Experiment (shots / readout)</a>
          <a href="#section-diagnostics"><span class="nDot"></span>Diagnostics (lasers / mm / camera)</a>
          <a href="#section-log"><span class="nDot"></span>Log</a>
        </nav>

        <div class="sideSectionTitle">Quick actions</div>
        <div class="qaGrid">
          <button id="qaPump" class="btn toggle" type="button" aria-pressed="false">Pump</button>
          <button id="qaOven" class="btn toggle" type="button" aria-pressed="false">Oven</button>
          <button id="qaBake" class="btn toggle" type="button" aria-pressed="false">Bake</button>
          <button id="qaCool" class="btn toggle" type="button" aria-pressed="false">Cool</button>
          <button id="qaLoad" class="btn warn" type="button">Load ions</button>
          <button id="qaReset" class="btn danger" type="button">Reset</button>
        </div>

        <div class="sideSectionTitle">Live summary</div>
        <div class="stack">
          <div class="card">
            <div class="k">Pressure</div>
            <div class="v" id="cardPressure">—</div>
            <div class="s" id="cardPressureHint">—</div>
          </div>
          <div class="card">
            <div class="k">Ions / n̄</div>
            <div class="v" id="cardIons">—</div>
            <div class="s" id="cardNbar">—</div>
          </div>
          <div class="card">
            <div class="k">RF / ωz</div>
            <div class="v" id="cardRF">—</div>
            <div class="s" id="cardWz">—</div>
          </div>
        </div>
      </div>
    </aside>

    <!-- MAIN -->
    <main class="main" role="main">
      <!-- OVERVIEW -->
      <section id="section-overview" data-section="overview">
        <div class="sectionHead">
          <div>
            <h2>Overview</h2>
            <p class="hint">A guided “lab-first” workflow: get vacuum → load ions → cool → compile → run → interpret readout.</p>
          </div>
          <div class="sectionTools">
            <button id="btnScrollProgram" class="btn ghost" type="button">Go to Program</button>
            <button id="btnScrollReadout" class="btn ghost" type="button">Go to Readout</button>
          </div>
        </div>

        <div class="cards" style="margin-top:10px;">
          <div class="card">
            <div class="k">System state</div>
            <div class="v" id="cardState">—</div>
            <div class="s">Ready status combines vacuum + ions loaded.</div>
          </div>
          <div class="card">
            <div class="k">Last run SPAM</div>
            <div class="v" id="cardSpam">—</div>
            <div class="s">Bit error proxy from last run.</div>
          </div>
          <div class="card">
            <div class="k">Tip</div>
            <div class="v" style="font-family:var(--sans); font-weight:850;">Ctrl+Enter</div>
            <div class="s">Run quickly. Press <span class="kbd">?</span> for shortcuts.</div>
          </div>
        </div>
      </section>

      <!-- SETUP -->
      <section id="section-setup" data-section="setup">
        <div class="sectionHead">
          <div>
            <h2>Setup</h2>
            <p class="hint">Vacuum + oven + loading, then trap settings. The live canvases update continuously.</p>
          </div>
        </div>

        <details class="panel" open data-title="Vacuum Oven Loading" id="panelVacuum">
          <summary>
            <div class="sumLeft">
              <div class="sumTitle">Vacuum, Oven, Loading</div>
              <div class="sumSub">Pump down, heat oven, load ions, cool (simple model)</div>
            </div>
            <div class="chev">▾</div>
          </summary>
          <div class="panelBody">
            <div class="grid2">
              <label>
                Base pressure
                <select id="selBaseP">
                  <option value="1e-12">1×10⁻¹² mbar</option>
                  <option value="3e-12">3×10⁻¹² mbar</option>
                  <option value="1e-11" selected>1×10⁻¹¹ mbar</option>
                  <option value="3e-11">3×10⁻¹¹ mbar</option>
                  <option value="1e-10">1×10⁻¹⁰ mbar</option>
                </select>
              </label>

              <label>
                PI scheme
                <select id="selPI">
                  <option value="none">None</option>
                  <option value="ca40" selected>Ca-40 (example)</option>
                  <option value="ca44">Ca-44 (example)</option>
                </select>
              </label>
            </div>

            <div class="grid2" style="margin-top:10px;">
              <label>
                Pump speed <span class="mono">(<span id="txtPump">65</span>%)</span>
                <input id="rngPump" type="range" min="0" max="100" value="65" />
              </label>

              <label>
                Oven set <span class="mono">(<span id="txtOvenSet">40</span>%)</span>
                <input id="rngOven" type="range" min="0" max="100" value="40" />
              </label>
            </div>

            <div class="row wrapRow" style="margin-top:10px;">
              <button id="btnPump" class="btn toggle" type="button" aria-pressed="false">Pump</button>
              <button id="btnBake" class="btn toggle" type="button" aria-pressed="false">Bake</button>
              <button id="btnOven" class="btn toggle" type="button" aria-pressed="false">Oven</button>
              <button id="btnLoad" class="btn warn" type="button">Load Ions</button>
              <button id="btnCool" class="btn toggle" type="button" aria-pressed="false">Cool</button>
              <button id="btnReset" class="btn danger" type="button">Reset</button>
            </div>

            <div class="sep"></div>

            <div class="kv">
              <div class="k">Pressure</div><div class="v" id="kvPressure">—</div>
              <div class="k">Oven temp</div><div class="v" id="kvOven">—</div>
              <div class="k">RF drive</div><div class="v" id="kvRF">—</div>
              <div class="k">ωz estimate</div><div class="v" id="kvWz">—</div>
              <div class="k">Ions</div><div class="v" id="kvIons">—</div>
              <div class="k">n̄</div><div class="v" id="kvNbar">—</div>
            </div>

            <div class="sep"></div>

            <canvas id="cvEnv" class="cv mini" aria-label="Vacuum and oven canvas"></canvas>
          </div>
        </details>

        <details class="panel" open data-title="Trap Fields" id="panelTrap">
          <summary>
            <div class="sumLeft">
              <div class="sumTitle">Trap & Fields</div>
              <div class="sumSub">RF / secular frequencies / B-field; shows a chain schematic</div>
            </div>
            <div class="chev">▾</div>
          </summary>
          <div class="panelBody">
            <div class="grid3">
              <label>RF f (MHz)<input id="numRFf" type="number" value="28.6" step="0.1" /></label>
              <label>RF V (Vpp)<input id="numRFv" type="number" value="180" step="1" /></label>
              <label>B (mT)<input id="numB" type="number" value="0.45" step="0.01" /></label>
            </div>
            <div class="grid2" style="margin-top:10px;">
              <label>ωz (MHz)<input id="numWz" type="number" value="1.10" step="0.01" /></label>
              <label>ωr (MHz)<input id="numWr" type="number" value="3.60" step="0.05" /></label>
            </div>

            <div class="sep"></div>
            <canvas id="cvIons" class="cv" aria-label="Ion chain canvas"></canvas>
          </div>
        </details>
      </section>

      <!-- PROGRAM -->
      <section id="section-program" data-section="program">
        <div class="sectionHead">
          <div>
            <h2>Program</h2>
            <p class="hint">Use a template, edit the sequence, compile, then run. Timeline updates on compile.</p>
          </div>
        </div>

        <details class="panel" open data-title="Pulse Program Compiler Timeline" id="panelProgram">
          <summary>
            <div class="sumLeft">
              <div class="sumTitle">Pulse Program</div>
              <div class="sumSub">Tiny DSL: <span class="mono">Doppler</span>, <span class="mono">OpticalPump</span>, <span class="mono">Pi/2</span>, <span class="mono">MS</span>, <span class="mono">Readout</span> (plus H/S/CNOT/CZ/Z…)</div>
            </div>
            <div class="chev">▾</div>
          </summary>
          <div class="panelBody">
            <div class="grid2">
              <label>
                Template
                <select id="selTemplate">
                  <option value="ramsey" selected>Ramsey</option>
                  <option value="bell">Bell (Pi/2 + MS)</option>
                  <option value="ms">MS Gate (entangler)</option>
                  <option value="rabi">Rabi</option>
                  <option value="readout">Readout Only</option>
                </select>
              </label>

              <div class="row" style="align-items:flex-end;">
                <button id="btnCompile" class="btn primary" type="button" style="flex:1;">Compile</button>
                <button id="btnRun" class="btn good" type="button" style="flex:1;">Run</button>
              </div>
            </div>

            <label style="margin-top:10px;">
              Program (one op per line)
              <textarea id="txtProgram" spellcheck="false"></textarea>
            </label>

            <div class="sep"></div>
            <canvas id="cvPulse" class="cv short" aria-label="Pulse timeline canvas"></canvas>
          </div>
        </details>
      </section>

      <!-- RUN / READOUT -->
      <section id="section-run" data-section="run">
        <div class="sectionHead">
          <div>
            <h2>Experiment</h2>
            <p class="hint">Choose qubits & shots, tune noise/readout, then inspect histogram + distribution.</p>
          </div>
        </div>

        <details class="panel" open data-title="Shots Noise Model" id="panelShots">
          <summary>
            <div class="sumLeft">
              <div class="sumTitle">Shot & Noise Model</div>
              <div class="sumSub">Qubits, shots, sensor mode, crosstalk, heating, decoherence</div>
            </div>
            <div class="chev">▾</div>
          </summary>
          <div class="panelBody">
            <div class="grid3">
              <label>Qubits<input id="numQ" type="number" min="1" max="16" value="4" step="1" /></label>
              <label>Shots<input id="numShots" type="number" min="1" max="50000" value="2000" step="100" /></label>
              <label>Sensor
                <select id="selSensor">
                  <option value="pmts" selected>PMTs</option>
                  <option value="camera">Camera</option>
                </select>
              </label>
            </div>

            <div class="grid3" style="margin-top:10px;">
              <label>XTalk (0–1)<input id="numXtalk" type="number" value="0.05" min="0" max="1" step="0.01" /></label>
              <label>T2 (ms)<input id="numT2" type="number" value="25" min="0.1" step="0.5" /></label>
              <label>Heat (q/ms)<input id="numHeat" type="number" value="0.03" min="0" step="0.01" /></label>
            </div>

            <details style="margin-top:10px;">
              <summary style="cursor:pointer; color:rgba(232,240,251,.9); font-weight:850;">
                Advanced error knobs
                <span style="color:var(--muted); font-weight:700;">(p1, p2)</span>
              </summary>
              <div class="grid2" style="margin-top:10px;">
                <label>Two-qubit p1 (1q proxy)<input id="numP1" type="number" value="0.006" min="0" max="1" step="0.001" /></label>
                <label>Two-qubit p2 (corr)<input id="numP2" type="number" value="0.002" min="0" max="1" step="0.001" /></label>
              </div>
            </details>
          </div>
        </details>

        <details class="panel" open data-title="Readout Histogram Distribution" id="panelReadout">
          <summary>
            <div class="sumLeft">
              <div class="sumTitle">Readout</div>
              <div class="sumSub">Counts model → classifier → SPAM estimate; histogram + outcome distribution</div>
            </div>
            <div class="chev">▾</div>
          </summary>
          <div class="panelBody">
            <div class="grid3">
              <label>Det. time (µs)<input id="numDetT" type="number" value="200" step="10" /></label>
              <label>Bright μ (cts)<input id="numBright" type="number" value="26" step="1" /></label>
              <label>Dark μ (cts)<input id="numDark" type="number" value="3" step="1" /></label>
            </div>

            <div class="grid3" style="margin-top:10px;">
              <label>Threshold (cts)<input id="numThresh" type="number" value="12" step="1" /></label>
              <label>Classifier
                <select id="selClassifier">
                  <option value="threshold" selected>Threshold</option>
                  <option value="naivebayes">Naive Bayes</option>
                  <option value="llr">LLR (slider)</option>
                </select>
              </label>
              <label>LLR <span class="mono">(<span id="txtLLR">0.0</span>)</span>
                <input id="rngLLR" type="range" min="-6" max="6" value="0" step="0.1" />
              </label>
            </div>

            <details style="margin-top:10px;">
              <summary style="cursor:pointer; color:rgba(232,240,251,.9); font-weight:850;">
                Advanced readout dynamics
                <span style="color:var(--muted); font-weight:700;">(bin / pump / depump)</span>
              </summary>
              <div class="grid3" style="margin-top:10px;">
                <label>Bin (µs)<input id="numBinUs" type="number" value="5" step="1" /></label>
                <label>Depump (Hz)<input id="numDepump" type="number" value="700" step="50" /></label>
                <label>Pump (Hz)<input id="numPump" type="number" value="250" step="25" /></label>
              </div>
            </details>

            <div class="sep"></div>
            <div class="kv">
              <div class="k">SPAM estimate</div><div class="v" id="txtSpam">—</div>
              <div class="k">Counts model</div><div class="v" id="txtCountsPhysical">—</div>
            </div>

            <div class="sep"></div>

            <div class="grid2">
              <div>
                <div style="font-size:11px; color:rgba(167,180,200,.85); font-weight:900; letter-spacing:.15px; text-transform:uppercase; margin-bottom:6px;">Readout Histogram</div>
                <canvas id="cvReadout" class="cv short" aria-label="Readout histogram canvas"></canvas>
              </div>
              <div>
                <div style="font-size:11px; color:rgba(167,180,200,.85); font-weight:900; letter-spacing:.15px; text-transform:uppercase; margin-bottom:6px;">Outcome Distribution</div>
                <canvas id="cvDist" class="cv short" aria-label="Outcome distribution canvas"></canvas>
              </div>
            </div>

            <div class="sep"></div>

            <div style="font-size:11px; color:rgba(167,180,200,.85); font-weight:900; letter-spacing:.15px; text-transform:uppercase; margin-bottom:6px;">Top outcomes</div>
            <table class="mono">
              <thead>
                <tr>
                  <th style="width:40%;">bitstring</th>
                  <th style="width:30%;">p</th>
                  <th style="width:30%;">N</th>
                </tr>
              </thead>
              <tbody id="tblOut"></tbody>
            </table>
          </div>
        </details>
      </section>

      <!-- DIAGNOSTICS -->
      <section id="section-diagnostics" data-section="diagnostics">
        <div class="sectionHead">
          <div>
            <h2>Diagnostics</h2>
            <p class="hint">Lasers, micromotion, camera. These are primarily visualization / UI-workflow aids.</p>
          </div>
        </div>

        <details class="panel" open data-title="Laser Rack" id="panelLasers">
          <summary>
            <div class="sumLeft">
              <div class="sumTitle">Laser Rack</div>
              <div class="sumSub">Lock toggles + simulated error readback + quick “kick”</div>
            </div>
            <div class="chev">▾</div>
          </summary>
          <div class="panelBody">
            <div class="grid2">
              <label class="row" style="flex-direction:row;justify-content:space-between;">
                <span>369 nm lock</span>
                <span class="row" style="gap:8px;">
                  <input id="chkL369" type="checkbox" checked />
                  <span id="spL369" class="spark ok"></span>
                </span>
              </label>

              <label class="row" style="flex-direction:row;justify-content:space-between;">
                <span>399 nm lock</span>
                <span class="row" style="gap:8px;">
                  <input id="chkL399" type="checkbox" checked />
                  <span id="spL399" class="spark ok"></span>
                </span>
              </label>

              <label class="row" style="flex-direction:row;justify-content:space-between;">
                <span>935 nm lock</span>
                <span class="row" style="gap:8px;">
                  <input id="chkL935" type="checkbox" checked />
                  <span id="spL935" class="spark ok"></span>
                </span>
              </label>

              <label class="row" style="flex-direction:row;justify-content:space-between;">
                <span>355 nm lock</span>
                <span class="row" style="gap:8px;">
                  <input id="chkL355" type="checkbox" checked />
                  <span id="spL355" class="spark ok"></span>
                </span>
              </label>

              <label class="row" style="flex-direction:row;justify-content:space-between;">
                <span>638 nm lock</span>
                <span class="row" style="gap:8px;">
                  <input id="chkL638" type="checkbox" checked />
                  <span id="spL638" class="spark ok"></span>
                </span>
              </label>

              <div class="kv" style="grid-column:1 / span 2;">
                <div class="k">369 err</div><div class="v" id="txtL369Err">—</div>
                <div class="k">399 err</div><div class="v" id="txtL399Err">—</div>
                <div class="k">935 err</div><div class="v" id="txtL935Err">—</div>
                <div class="k">355 err</div><div class="v" id="txtL355Err">—</div>
                <div class="k">638 err</div><div class="v" id="txtL638Err">—</div>
              </div>
            </div>

            <div class="row wrapRow" style="margin-top:10px;">
              <button id="btnLockAll" class="btn good" type="button">Lock all</button>
              <button id="btnUnlockAll" class="btn warn" type="button">Unlock all</button>
              <button id="btnKickLasers" class="btn" type="button">Kick</button>
            </div>

            <div class="sep"></div>
            <canvas id="cvLaser" class="cv short" aria-label="Laser diagnostic canvas"></canvas>
          </div>
        </details>

        <details class="panel" open data-title="Micromotion" id="panelMM">
          <summary>
            <div class="sumLeft">
              <div class="sumTitle">Micromotion</div>
              <div class="sumSub">Comp knobs → sideband proxy; auto step toward optimum</div>
            </div>
            <div class="chev">▾</div>
          </summary>
          <div class="panelBody">
            <div class="grid2">
              <label>Comp X (V)<input id="numCompX" type="number" value="0.00" step="0.02" /></label>
              <label>Comp Y (V)<input id="numCompY" type="number" value="0.00" step="0.02" /></label>
            </div>

            <div class="sep"></div>
            <div class="kv">
              <div class="k">MM amp</div><div class="v" id="txtMMamp">—</div>
              <div class="k">SB ratio</div><div class="v" id="txtMMratio">—</div>
            </div>

            <div class="row wrapRow" style="margin-top:10px;">
              <button id="btnAutoMM" class="btn primary" type="button">Auto-minimize</button>
            </div>

            <div class="sep"></div>
            <canvas id="cvMM" class="cv short" aria-label="Micromotion diagnostic canvas"></canvas>
          </div>
        </details>

        <details class="panel" open data-title="Camera View" id="panelCam">
          <summary>
            <div class="sumLeft">
              <div class="sumTitle">Camera View</div>
              <div class="sumSub">Render a synthetic frame after running with Sensor=Camera</div>
            </div>
            <div class="chev">▾</div>
          </summary>
          <div class="panelBody">
            <div class="row wrapRow">
              <label style="flex:1; min-width:150px;">
                Mode
                <select id="selHelpCamMode" style="display:none;"></select>
                <select id="selCamMode">
                  <option value="counts" selected>Counts</option>
                  <option value="image">Image</option>
                </select>
              </label>

              <label style="flex:1; min-width:150px;">
                Gain <span class="mono">(<span id="txtCamGain">1.0</span>×)</span>
                <input id="rngCamGain" type="range" min="0.5" max="5" step="0.1" value="1.0" />
              </label>
            </div>

            <div class="row wrapRow" style="margin-top:10px;">
              <label style="flex:1; min-width:150px;">
                Blur σ <span class="mono">(<span id="txtCamSigma">1.0</span> px)</span>
                <input id="rngCamSigma" type="range" min="0.4" max="3.0" step="0.1" value="1.0" />
              </label>

              <label style="flex:1; min-width:150px;">
                Pixel scale (µm/px)
                <input id="numCamScale" type="number" value="1.2" step="0.1" />
              </label>
            </div>

            <div class="row wrapRow" style="margin-top:10px;">
              <label style="flex:1; min-width:150px;">
                ROI half-width (px)
                <input id="numCamROI" type="number" value="14" step="1" min="4" />
              </label>

              <label style="flex:1; min-width:150px;">
                Overlay
                <select id="selCamOverlay">
                  <option value="none" selected>None</option>
                  <option value="roi">ROI</option>
                  <option value="centroid">Centroid</option>
                </select>
              </label>
            </div>

            <div class="sep"></div>
            <canvas id="cvCam" class="cv" aria-label="Camera canvas"></canvas>
          </div>
        </details>

        <details class="panel" data-title="Calibration Placeholder" id="panelCal">
          <summary>
            <div class="sumLeft">
              <div class="sumTitle">Calibration (placeholder)</div>
              <div class="sumSub">A stub plot + table: wire in scan routines if desired</div>
            </div>
            <div class="chev">▾</div>
          </summary>
          <div class="panelBody">
            <canvas id="cvCal" class="cv short" aria-label="Calibration plot canvas"></canvas>
            <div class="sep"></div>
            <table class="mono">
              <thead>
                <tr>
                  <th style="width:22%;">type</th>
                  <th style="width:22%;">x</th>
                  <th style="width:22%;">y</th>
                  <th style="width:34%;">note</th>
                </tr>
              </thead>
              <tbody id="tblCal"></tbody>
            </table>
          </div>
        </details>
      </section>

      <!-- LOG -->
      <section id="section-log" data-section="log">
        <div class="sectionHead">
          <div>
            <h2>Log</h2>
            <p class="hint">A compact record of actions and run summaries. Use Copy/Clear for quick sharing.</p>
          </div>
        </div>

        <details class="panel" open data-title="Log" id="panelLog">
          <summary>
            <div class="sumLeft">
              <div class="sumTitle">Console Log</div>
              <div class="sumSub">What the “control computer” did</div>
            </div>
            <div class="chev">▾</div>
          </summary>
          <div class="panelBody">
            <div class="logWrap">
              <div class="logBar">
                <div class="row wrapRow">
                  <button id="btnCopyLog" class="btn" type="button">Copy</button>
                  <button id="btnClearLog" class="btn danger" type="button">Clear</button>
                </div>
                <div style="color:rgba(167,180,200,.85); font-size:12px;">
                  Tip: Filter panels from the top bar (e.g., “laser”).
                </div>
              </div>
              <pre id="log" class="log"></pre>
            </div>
          </div>
        </details>
      </section>
    </main>

    <!-- RIGHT / LIVE PLOTS -->
    <aside class="right" aria-label="Live plots">
      <details class="panel" open data-title="Photon Trace" id="panelPhoton">
        <summary>
          <div class="sumLeft">
            <div class="sumTitle">Photon Trace</div>
            <div class="sumSub">Toy trace driven by pressure + n̄ (placeholder)</div>
          </div>
          <div class="chev">▾</div>
        </summary>
        <div class="panelBody">
          <canvas id="cvPhoton" class="cv short" aria-label="Photon trace canvas"></canvas>
        </div>
      </details>

      <details class="panel" open data-title="MS Diagnostic" id="panelMS">
        <summary>
          <div class="sumLeft">
            <div class="sumTitle">MS Diagnostic</div>
            <div class="sumSub">Visual proxy: shows last MS pulse & detuning heuristic</div>
          </div>
          <div class="chev">▾</div>
        </summary>
        <div class="panelBody">
          <canvas id="cvMS" class="cv short" aria-label="MS diagnostic canvas"></canvas>
        </div>
      </details>

      <details class="panel" data-title="Spare Plot" id="panelSpare">
        <summary>
          <div class="sumLeft">
            <div class="sumTitle">Spare</div>
            <div class="sumSub">Reserved for extra plots / scans</div>
          </div>
          <div class="chev">▾</div>
        </summary>
        <div class="panelBody">
          <canvas class="cv short" aria-label="Spare canvas"></canvas>
        </div>
      </details>
    </aside>
  </div>

  <div id="tooltip" class="tt" role="tooltip" aria-hidden="true"></div>
  <div id="toast" class="toast" role="status" aria-live="polite"></div>

  <dialog id="dlgHelp" aria-labelledby="dlgHelpTitle">
    <div class="dlgHd">
      <h3 id="dlgHelpTitle">Help & user manual</h3>
      <form method="dialog">
        <button class="btn ghost" value="close" type="submit" aria-label="Close help" data-tip="Close the help / user manual dialog.">Close</button>
      </form>
    </div>

    <div class="dlgBd">
      <div class="manual">
        <h4>Keyboard shortcuts</h4>
        <ul>
          <li><span class="kbd">Ctrl</span>/<span class="kbd">⌘</span> + <span class="kbd">Enter</span>: Run</li>
          <li><span class="kbd">Ctrl</span>/<span class="kbd">⌘</span> + <span class="kbd">Shift</span> + <span class="kbd">Enter</span>: Compile</li>
          <li><span class="kbd">?</span>: Toggle this help</li>
          <li><span class="kbd">Esc</span>: Close nav/help + dismiss tooltips</li>
        </ul>

        <h4>Quickstart</h4>
        <ol>
          <li>Open <b>Setup → Vacuum</b> and toggle <code>Pump</code> (optionally <code>Bake</code>) until pressure is reasonable.</li>
          <li>Click <code>Load Ions</code> (or use the sidebar <code>Load ions</code>).</li>
          <li>Toggle <code>Cool</code> to reduce <code>n̄</code> over time.</li>
          <li>Go to <b>Program</b>, pick a template, then press <code>Compile</code>.</li>
          <li>Go to <b>Experiment</b>, set qubits/shots, then press <code>Run</code>.</li>
          <li>Inspect <b>Readout</b>: histogram + top outcomes + SPAM estimate.</li>
        </ol>

        <h4>Tooltips</h4>
        <p>
          Tooltips are intentionally subtle:
          they appear after a short hover delay and <b>never block clicks</b>.
          Use the <code>Tooltips</code> button in the top bar to toggle them on/off.
        </p>

        <h4>Pulse program DSL</h4>
        <p>
          <b>Format:</b> one operation per line:
          <code>Op [targets...] Duration</code>.
          Targets are optional (<code>q0</code>, <code>q1</code>, … or just <code>0</code>, <code>1</code>, …).
          Duration units: <code>us</code>, <code>µs</code>, <code>ms</code>, <code>s</code>.
        </p>

        <pre># Ramsey on qubit 0
Doppler 2ms
OpticalPump 200us
Pi/2 q0 10us
Wait 50us
Pi/2 q0 10us
Readout 200us

# Two-ion Bell state (|Φ+⟩) using Pi/2 + MS
Doppler 2ms
OpticalPump 200us
Pi/2 q0 10us
MS q0 q1 60us
Readout 200us</pre>

        <p>
          <b>Defaults (if you omit targets):</b>
          1‑qubit gates default to <code>q0</code>.
          2‑qubit gates default to <code>q0 q1</code>.
        </p>

        <p><b>Supported ops:</b></p>
        <ul>
          <li><code>Doppler</code>, <code>OpticalPump</code>, <code>Wait</code>, <code>Readout</code></li>
          <li><code>Pi</code>/<code>X</code>/<code>Rabi</code> (modeled as X)</li>
          <li><code>Pi/2</code> (modeled as H / “Hadamard-like”)</li>
          <li><code>H</code>, <code>S</code>, <code>Sdg</code>, <code>Z</code></li>
          <li><code>MS</code> (modeled as a CNOT-like entangler for circuit-level work)</li>
          <li><code>CNOT</code>, <code>CZ</code></li>
        </ul>

        <h4>What “physics” is actually simulated</h4>
        <p>
          Circuit evolution uses a <b>stabilizer tableau (Clifford) simulator</b> (efficient; not a statevector).
          Noise is applied stochastically per shot as Pauli channels: time‑based <code>T2</code> dephasing plus <code>p1/p2</code>
          depolarization (with extra penalties from heating/n̄/micromotion/laser error heuristics).
          Readout uses the photon-count model and your classifier settings.
        </p>

        <h4>Troubleshooting</h4>
        <ul>
          <li><b>“Bad duration” errors</b>: the last token must be a duration like <code>10us</code> or <code>2ms</code>.</li>
          <li><b>You pasted escaped newlines</b>: the editor fixes literal <code>\n</code>, but if you see one giant line, paste with real line breaks.</li>
          <li><b>Bell state looks wrong</b>: use the Bell template or ensure you have <code>Pi/2 q0</code> then <code>MS q0 q1</code>. If you see mostly <code>10</code>, it usually means the entangler isn’t being applied to the intended pair.</li>
          <li><b>High SPAM</b>: adjust readout settings (Bright/Dark μ, Threshold, detection time), reduce XTalk, increase T2, lower heat.</li>
        </ul>
      </div>
    </div>

    <div class="dlgFt">
      <form method="dialog">
        <button class="btn primary" value="close" type="submit" data-tip="Close the help dialog.">Got it</button>
      </form>
    </div>
  </dialog>

  <script type="module">
    /********************
     * Utility & UI cache
     ********************/
    const $ = (id) => document.getElementById(id);

    const ui = {
      // top controls
      btnNav: $('btnNav'),
      btnCloseNav: $('btnCloseNav'),
      navOverlay: $('navOverlay'),
      txtFilter: $('txtFilter'),
      btnCompileTop: $('btnCompileTop'),
      btnRunTop: $('btnRunTop'),
      btnTips: $('btnTips'),
      btnHelp: $('btnHelp'),
      dlgHelp: $('dlgHelp'),
      tooltip: $('tooltip'),
      toast: $('toast'),

      // quick actions
      qaPump: $('qaPump'),
      qaOven: $('qaOven'),
      qaBake: $('qaBake'),
      qaCool: $('qaCool'),
      qaLoad: $('qaLoad'),
      qaReset: $('qaReset'),

      // navigation
      nav: $('nav'),

      // overview cards
      cardState: $('cardState'),
      cardSpam: $('cardSpam'),
      cardPressure: $('cardPressure'),
      cardPressureHint: $('cardPressureHint'),
      cardIons: $('cardIons'),
      cardNbar: $('cardNbar'),
      cardRF: $('cardRF'),
      cardWz: $('cardWz'),
      btnScrollProgram: $('btnScrollProgram'),
      btnScrollReadout: $('btnScrollReadout'),

      // canvases
      cvEnv: $('cvEnv'),
      cvIons: $('cvIons'),
      cvPulse: $('cvPulse'),
      cvReadout: $('cvReadout'),
      cvDist: $('cvDist'),
      cvCam: $('cvCam'),
      cvPhoton: $('cvPhoton'),
      cvMS: $('cvMS'),
      cvLaser: $('cvLaser'),
      cvMM: $('cvMM'),
      cvCal: $('cvCal'),

      // log
      log: $('log'),
      btnCopyLog: $('btnCopyLog'),
      btnClearLog: $('btnClearLog'),

      // status / kv
      dotReady: $('dotReady'),
      readyTxt: $('readyTxt'),
      kvPressure: $('kvPressure'),
      kvOven: $('kvOven'),
      kvRF: $('kvRF'),
      kvWz: $('kvWz'),
      kvIons: $('kvIons'),
      kvNbar: $('kvNbar'),

      // vacuum controls
      selBaseP: $('selBaseP'),
      rngPump: $('rngPump'),
      txtPump: $('txtPump'),
      rngOven: $('rngOven'),
      txtOvenSet: $('txtOvenSet'),
      selPI: $('selPI'),
      btnPump: $('btnPump'),
      btnBake: $('btnBake'),
      btnOven: $('btnOven'),
      btnLoad: $('btnLoad'),
      btnCool: $('btnCool'),
      btnReset: $('btnReset'),

      // trap numbers
      numRFf: $('numRFf'),
      numRFv: $('numRFv'),
      numWz: $('numWz'),
      numWr: $('numWr'),
      numB: $('numB'),

      // program
      txtProgram: $('txtProgram'),
      selTemplate: $('selTemplate'),
      btnCompile: $('btnCompile'),
      btnRun: $('btnRun'),

      // shots & noise
      numQ: $('numQ'),
      numShots: $('numShots'),
      selSensor: $('selSensor'),
      numXtalk: $('numXtalk'),
      numT2: $('numT2'),
      numHeat: $('numHeat'),
      numP1: $('numP1'),
      numP2: $('numP2'),

      // readout
      numDetT: $('numDetT'),
      numBright: $('numBright'),
      numDark: $('numDark'),
      numThresh: $('numThresh'),
      selClassifier: $('selClassifier'),
      numBinUs: $('numBinUs'),
      numDepump: $('numDepump'),
      numPump: $('numPump'),
      rngLLR: $('rngLLR'),
      txtLLR: $('txtLLR'),
      txtSpam: $('txtSpam'),
      txtCountsPhysical: $('txtCountsPhysical'),

      // micromotion
      numCompX: $('numCompX'),
      numCompY: $('numCompY'),
      txtMMamp: $('txtMMamp'),
      txtMMratio: $('txtMMratio'),
      btnAutoMM: $('btnAutoMM'),

      // lasers
      chkL369: $('chkL369'),
      chkL399: $('chkL399'),
      chkL935: $('chkL935'),
      chkL355: $('chkL355'),
      chkL638: $('chkL638'),
      txtL369Err: $('txtL369Err'),
      txtL399Err: $('txtL399Err'),
      txtL935Err: $('txtL935Err'),
      txtL355Err: $('txtL355Err'),
      txtL638Err: $('txtL638Err'),
      spL369: $('spL369'),
      spL399: $('spL399'),
      spL935: $('spL935'),
      spL355: $('spL355'),
      spL638: $('spL638'),
      btnLockAll: $('btnLockAll'),
      btnUnlockAll: $('btnUnlockAll'),
      btnKickLasers: $('btnKickLasers'),

      // camera
      selCamMode: $('selCamMode'),
      rngCamGain: $('rngCamGain'),
      txtCamGain: $('txtCamGain'),
      rngCamSigma: $('rngCamSigma'),
      txtCamSigma: $('txtCamSigma'),
      numCamScale: $('numCamScale'),
      numCamROI: $('numCamROI'),
      selCamOverlay: $('selCamOverlay'),

      // tables
      tblOut: $('tblOut'),
      tblCal: $('tblCal'),
    };

    const nowMs = () => performance.now();

    // Resolve CSS variables for canvas colors (canvas can't reliably interpret "var(--x)")
    const COLORS = {};
    function refreshColors(){
      const cs = getComputedStyle(document.documentElement);
      const get = (k) => cs.getPropertyValue(k).trim();
      COLORS.ok = get('--ok') || '#2fe39a';
      COLORS.warn = get('--warn') || '#ffd27b';
      COLORS.bad = get('--bad') || '#ff6b6b';
      COLORS.text = get('--text') || '#e9f0fb';
      COLORS.muted = get('--muted') || '#a7b4c8';
      COLORS.stroke = get('--stroke') || 'rgba(255,255,255,.10)';
    }
    refreshColors();

    let toastTimer = null;
    function toast(msg){
      if(!ui.toast) return;
      ui.toast.textContent = msg;
      ui.toast.classList.add('show');
      clearTimeout(toastTimer);
      toastTimer = setTimeout(() => ui.toast.classList.remove('show'), 2200);
    }

    function log(msg){
      const t = new Date().toLocaleTimeString();
      ui.log.textContent += `[${t}] ${msg}\n`;
      ui.log.scrollTop = ui.log.scrollHeight;
    }

    /********************
     * Subtle tooltip system (less invasive)
     ********************/
    const Tooltip = (() => {
      const el = ui.tooltip;

      let enabled = true;
      let active = null;
      let showTimer = null;
      let hideTimer = null;
      let lastInput = 'pointer';

      const HOVER_DELAY_MS = 450;
      const HIDE_DELAY_MS = 80;
      const TOUCH_AUTOHIDE_MS = 2400;

      const canHover = window.matchMedia?.('(hover: hover)')?.matches ?? true;
      const isTouchLike = window.matchMedia?.('(hover: none)')?.matches ?? false;

      function clearTimers(){
        clearTimeout(showTimer); showTimer = null;
        clearTimeout(hideTimer); hideTimer = null;
      }

      function setEnabled(on){
        enabled = !!on;
        if(!enabled) dismiss();
      }

      function placeForTarget(target){
        if(!target || !el) return;
        const rect = target.getBoundingClientRect();
        const margin = 10;
        const pad = 10;

        // Measure after content is set.
        const w = el.offsetWidth || 280;
        const h = el.offsetHeight || 44;

        const vw = window.innerWidth;
        const vh = window.innerHeight;

        // Prefer below with a slight horizontal offset.
        let x = rect.left + Math.min(24, rect.width * 0.25);
        let y = rect.bottom + pad;

        if(x + w > vw - margin) x = vw - w - margin;
        if(x < margin) x = margin;

        // If clipped at bottom, flip above.
        if(y + h > vh - margin) y = rect.top - h - pad;
        if(y < margin) y = margin;

        el.style.transform = `translate(${Math.round(x)}px, ${Math.round(y)}px)`;
      }

      function showNow(target, {autohide=false} = {}){
        if(!enabled || !el) return;
        const msg = (target?.dataset?.tip || '').trim();
        if(!msg) return;

        clearTimers();
        active = target;

        // aria-describedby: preserve any existing value
        const prev = target.getAttribute('aria-describedby') || '';
        target.dataset.prevDesc = prev;
        const toks = new Set(prev.split(/\s+/).filter(Boolean));
        toks.add('tooltip');
        target.setAttribute('aria-describedby', [...toks].join(' '));

        el.textContent = msg;
        el.classList.add('show');
        el.setAttribute('aria-hidden', 'false');

        requestAnimationFrame(() => placeForTarget(target));

        if(autohide){
          hideTimer = setTimeout(() => dismiss(), TOUCH_AUTOHIDE_MS);
        }
      }

      function scheduleShow(target){
        if(!enabled || !target?.dataset?.tip) return;
        clearTimers();
        showTimer = setTimeout(() => showNow(target), HOVER_DELAY_MS);
      }

      function scheduleHide(){
        clearTimers();
        hideTimer = setTimeout(() => dismiss(), HIDE_DELAY_MS);
      }

      function dismiss(){
        clearTimers();
        if(!el) return;
        el.classList.remove('show');
        el.setAttribute('aria-hidden', 'true');
        el.style.transform = 'translate(-9999px,-9999px)';

        if(active){
          const prev = active.dataset.prevDesc || '';
          if(prev) active.setAttribute('aria-describedby', prev);
          else active.removeAttribute('aria-describedby');
          delete active.dataset.prevDesc;
        }
        active = null;
      }

      function attach(node){
        if(!node || node.dataset.tipBound === '1') return;
        node.dataset.tipBound = '1';

        if(canHover){
          node.addEventListener('pointerenter', () => scheduleShow(node));
          node.addEventListener('pointerleave', () => scheduleHide());
          node.addEventListener('pointerdown', () => { lastInput = 'pointer'; dismiss(); });
        } else {
          node.addEventListener('pointerdown', () => { lastInput = 'pointer'; dismiss(); });
        }

        node.addEventListener('focus', () => {
          if(!node.dataset.tip) return;
          const focusViaKeyboard = (lastInput === 'keyboard');
          if(focusViaKeyboard){
            showNow(node);
          } else if(isTouchLike){
            showNow(node, {autohide:true});
          }
        });

        node.addEventListener('blur', () => scheduleHide());
      }

      function refresh(){
        document.querySelectorAll('[data-tip]').forEach(attach);
      }

      // Input modality tracking (capture phase to be early)
      window.addEventListener('keydown', () => { lastInput = 'keyboard'; }, true);
      window.addEventListener('pointerdown', () => { lastInput = 'pointer'; }, true);

      window.addEventListener('scroll', () => { if(active) placeForTarget(active); }, {passive:true});
      window.addEventListener('resize', () => { if(active) placeForTarget(active); }, {passive:true});

      return { refresh, dismiss, setEnabled, get enabled(){ return enabled; } };
    })();

    function applyTooltips(){
      const TIP = {
        // top bar
        btnNav: 'Open the navigation sidebar (especially useful on mobile).',
        btnCloseNav: 'Close the navigation sidebar.',
        navOverlay: 'Click to close the navigation sidebar.',
        txtFilter: 'Filter panels/controls by keyword (matches titles + panel text).',
        btnCompileTop: 'Compile the pulse program and update the timeline. Shortcut: Ctrl/⌘ + Shift + Enter.',
        btnRunTop: 'Compile then run shots with current settings. Shortcut: Ctrl/⌘ + Enter.',
        btnTips: 'Toggle tooltips on/off (tooltips are delayed and never block clicks).',
        btnHelp: 'Open the user manual and shortcuts. Shortcut: ?',

        // quick actions
        qaPump: 'Toggle the vacuum pump.',
        qaBake: 'Toggle bake-out (reduces outgassing over time in this toy model).',
        qaOven: 'Toggle the atomic oven (increases loading/outgassing).',
        qaCool: 'Toggle cooling (reduces n̄ in this toy model).',
        qaLoad: 'Load an ion chain (uses the current “Qubits” value).',
        qaReset: 'Reset the simulator state and clear run results.',

        // navigation
        btnScrollProgram: 'Scroll to the Program section.',
        btnScrollReadout: 'Scroll to the Readout panel.',

        // setup controls
        selBaseP: 'Choose the base (ultimate) pressure of the system.',
        selPI: 'Pick a (toy) photoionization scheme.',
        rngPump: 'Pump throttle: higher usually lowers pressure faster.',
        rngOven: 'Oven setpoint: higher increases temperature and outgassing.',
        btnPump: 'Toggle the vacuum pump on/off.',
        btnBake: 'Toggle bake-out on/off.',
        btnOven: 'Toggle oven on/off.',
        btnLoad: 'Load ions into the trap (toy model).',
        btnCool: 'Toggle cooling on/off (affects n̄).',
        btnReset: 'Reset the entire simulator state.',

        // trap
        numRFf: 'RF drive frequency (MHz). Affects the toy trap heuristic.',
        numRFv: 'RF amplitude (Vpp). Affects the toy trap heuristic.',
        numB: 'Magnetic field (mT). Display-only in the toy model.',
        numWz: 'Axial secular frequency ωz (MHz).',
        numWr: 'Radial secular frequency ωr (MHz).',

        // program
        selTemplate: 'Load an example pulse sequence template into the editor.',
        txtProgram: 'Pulse program editor. One op per line: “Op [q0 q1 ...] 10us”. Duration must be last token. Units: us/µs/ms/s.',
        btnCompile: 'Compile the program and draw the timeline.',
        btnRun: 'Compile + run the program to generate shot outcomes and readout histograms.',

        // shots/noise
        numQ: 'Number of qubits / ions for the experiment (1–16).',
        numShots: 'Number of shots (Monte-Carlo samples). Higher = smoother stats.',
        selSensor: 'Choose PMTs (per-ion counts) or Camera (synthetic frame).',
        numXtalk: 'Readout crosstalk: bright ions can “bleed” into neighbors.',
        numT2: 'Decoherence time constant T2 (ms) used for time-based dephasing.',
        numHeat: 'Heating rate (quanta per ms) added to n̄ dynamics and gate infidelity heuristics.',
        numP1: 'Single-qubit depolarizing probability applied after 1-qubit gates (toy).',
        numP2: 'Two-qubit depolarizing probability applied after entangling gates (toy).',

        // readout
        numDetT: 'Detection time per shot (µs). Scales expected photon counts.',
        numBright: 'Expected bright-state photon counts (μ) at 200µs (toy).',
        numDark: 'Expected dark-state photon counts (μ) at 200µs (toy).',
        numThresh: 'Threshold classifier cut (counts ≥ threshold ⇒ bright).',
        selClassifier: 'Counts-to-bit classifier mode.',
        rngLLR: 'LLR offset: shifts the effective threshold when Classifier=LLR.',
        numBinUs: 'Bin width (µs) for advanced readout dynamics (toy).',
        numDepump: 'Depump rate (Hz): bright → dark during detection (toy).',
        numPump: 'Pump rate (Hz): dark → bright during detection (toy).',

        // diagnostics
        chkL369: 'Toggle 369 nm lock (toy). Off increases drift/error.',
        chkL399: 'Toggle 399 nm lock (toy).',
        chkL935: 'Toggle 935 nm lock (toy).',
        chkL355: 'Toggle 355 nm lock (toy).',
        chkL638: 'Toggle 638 nm lock (toy).',
        btnLockAll: 'Enable all laser locks.',
        btnUnlockAll: 'Disable all laser locks.',
        btnKickLasers: 'Apply a disturbance to all laser errors (toy).',

        numCompX: 'Micromotion compensation X (V).',
        numCompY: 'Micromotion compensation Y (V).',
        btnAutoMM: 'Auto-step compensation toward the optimum (toy).',

        selCamMode: 'Camera display mode.',
        rngCamGain: 'Camera gain applied to synthetic counts.',
        rngCamSigma: 'Blur sigma for the synthetic camera PSF.',
        numCamScale: 'Pixel scale (µm/px). Display-only in this toy model.',
        numCamROI: 'ROI half-width for centroid calculation.',
        selCamOverlay: 'Optional overlay (ROI box or centroid crosshair).',

        // log
        btnCopyLog: 'Copy the log text to your clipboard.',
        btnClearLog: 'Clear the log.',

        // canvases
        cvEnv: 'Vacuum + oven visualization (pressure scale + oven temperature bar).',
        cvIons: 'Ion chain schematic (brightness depends on n̄).',
        cvPulse: 'Compiled pulse timeline (relative durations).',
        cvReadout: 'Histogram of photon counts for bright/dark samples.',
        cvDist: 'Outcome distribution for the most likely bitstrings.',
        cvCam: 'Synthetic camera frame (only populated when Sensor=Camera).',
        cvPhoton: 'Toy photon trace driven by pressure + n̄ (placeholder).',
        cvMS: 'MS loop closure / detuning heuristic (toy).',
        cvLaser: 'Laser error bars (toy).',
        cvMM: 'Micromotion sideband proxy (toy).',
        cvCal: 'Calibration placeholder plot.'
      };

      for(const [id, msg] of Object.entries(TIP)){
        const el = $(id);
        if(el) el.dataset.tip = msg;
      }

      // Readiness pill (not an input, but useful)
      const pill = document.querySelector('.pill');
      if(pill){
        pill.dataset.tip =
          'Overall readiness indicator.\n' +
          'READY = vacuum OK + ions loaded.\n' +
          'VAC = pressure too high.\n' +
          'NO IONS = vacuum OK but no ions loaded.';
      }

      // Panel summaries: add “expand/collapse” context
      const panelTips = {
        panelVacuum: 'Vacuum, oven, and loading controls. Expand/collapse this panel.',
        panelTrap: 'Trap RF/secular parameters and ion-chain view. Expand/collapse this panel.',
        panelProgram: 'Pulse program editor + compiler timeline. Expand/collapse this panel.',
        panelShots: 'Shot count and noise model knobs. Expand/collapse this panel.',
        panelReadout: 'Readout model, classifier, histogram, and outcome distribution. Expand/collapse this panel.',
        panelLasers: 'Laser lock toggles and error readback (toy). Expand/collapse this panel.',
        panelMM: 'Micromotion compensation knobs and proxy metric. Expand/collapse this panel.',
        panelCam: 'Synthetic camera settings and frame view. Expand/collapse this panel.',
        panelCal: 'Calibration placeholder. Expand/collapse this panel.',
        panelLog: 'Console log of actions and run summaries. Expand/collapse this panel.',
        panelPhoton: 'Right-side toy photon trace. Expand/collapse this panel.',
        panelMS: 'Right-side MS diagnostic proxy. Expand/collapse this panel.',
        panelSpare: 'Spare plot area (placeholder). Expand/collapse this panel.'
      };

      document.querySelectorAll('details.panel').forEach(d => {
        const sum = d.querySelector(':scope > summary');
        if(!sum) return;
        const id = d.id || '';
        sum.dataset.tip = panelTips[id] || `Expand/collapse panel: ${(d.getAttribute('data-title')||'').trim() || 'Panel'}.`;
      });

      // Nav links: explain jump
      (ui.nav?.querySelectorAll('a') || []).forEach(a => {
        const label = a.textContent.replace(/\s+/g,' ').trim();
        a.dataset.tip = `Jump to: ${label}`;
      });

      // Advanced details summaries
      document.querySelectorAll('#panelShots details > summary, #panelReadout details > summary').forEach(s => {
        if(!s.dataset.tip){
          s.dataset.tip = 'Show/hide advanced settings.';
        }
      });

      Tooltip.refresh();
    }

    /********************
     * Canvas helpers
     ********************/
    function ensureCanvas(c){
      if(!c) return null;
      const dpr = Math.max(1, window.devicePixelRatio || 1);
      const w = Math.max(2, Math.floor(c.clientWidth * dpr));
      const h = Math.max(2, Math.floor(c.clientHeight * dpr));
      if(c.width !== w || c.height !== h){
        c.width = w; c.height = h;
      }
      const ctx = c.getContext('2d');
      ctx.setTransform(1,0,0,1,0,0);
      return ctx;
    }

    function clear(ctx){
      const c = ctx.canvas;
      ctx.clearRect(0,0,c.width,c.height);
    }

    function axes(ctx, title){
      const c = ctx.canvas;
      ctx.save();
      // background
      ctx.fillStyle = 'rgba(255,255,255,.05)';
      ctx.fillRect(0,0,c.width,c.height);
      // frame
      ctx.strokeStyle = 'rgba(255,255,255,.10)';
      ctx.lineWidth = 2;
      ctx.strokeRect(2,2,c.width-4,c.height-4);

      ctx.fillStyle = 'rgba(232,240,251,.88)';
      ctx.font = `900 ${Math.max(12, Math.floor(c.height/16))}px ${getComputedStyle(document.body).fontFamily}`;
      ctx.fillText(title, 10, 22);
      ctx.restore();
    }

    function map(x, a,b, c,d){
      if(b===a) return (c+d)/2;
      return c + (x-a)*(d-c)/(b-a);
    }

    /********************
     * Simple lab / environment state (toy)
     ********************/
    const lab = {
      t: 0,
      last: nowMs(),
      baseP: 1e-11,
      pumpOn: false,
      bakeOn: false,
      ovenOn: false,
      coolingOn: false,
      ovenSet: 0.4,     // 0..1
      pumpSpeed: 0.65,  // 0..1

      pressure: 1e-9,
      ovenTempC: 25,
      ionsLoaded: 0,
      nbar: 8.0,

      rf: { fMHz: 28.6, vpp: 180 },
      trap: { wzMHz: 1.10, wrMHz: 3.60, BmT: 0.45 },

      ions: [],

      program: { text:'', compiled:[], lastError:null },
      cal: { points:[], tableRows:[] },

      readout: { lastBrightCounts:[], lastDarkCounts:[], lastSpam:null },

      mm: { compX: 0, compY: 0, amp: 0.25, ratio: 0.18 },

      lasers: {
        L369:{ lock:true, err:0 },
        L399:{ lock:true, err:0 },
        L935:{ lock:true, err:0 },
        L355:{ lock:true, err:0 },
        L638:{ lock:true, err:0 }
      },

      cam: {
        mode:'counts',
        gain:1.0,
        sigma:1.0,
        scaleUmPerPx:1.2,
        roiHalf:14,
        overlay:'none',
        lastImage:null,
        lastCounts:null,
        centroid:null
      }
    };

    function clamp(x, lo, hi){ return Math.min(hi, Math.max(lo, x)); }
    function randn(){
      let u = 0, v = 0;
      while(u === 0) u = Math.random();
      while(v === 0) v = Math.random();
      return Math.sqrt(-2.0*Math.log(u)) * Math.cos(2.0*Math.PI*v);
    }
    function poisson(lambda){
      lambda = Math.max(0, lambda);
      if(lambda <= 0) return 0;
      const L = Math.exp(-lambda);
      let k = 0, p = 1;
      do { k++; p *= Math.random(); } while(p > L);
      return k - 1;
    }

    // Very rough vacuum/oven model
    function pressureUpdate(dt){
      lab.baseP = parseFloat(ui.selBaseP.value);

      const targetBase = lab.baseP;
      const pump = lab.pumpOn ? (0.15 + 0.85*lab.pumpSpeed) : 0.0;
      const bake = lab.bakeOn ? 1.0 : 0.0;
      const oven = lab.ovenOn ? lab.ovenSet : 0.0;

      // outgassing increases with bake and oven
      const outgas = (1e-11)*(1 + 12*bake + 18*oven);

      const desired = Math.max(targetBase + outgas, 2e-12);
      const kPump = 0.65 * pump;
      const kLeak = 0.03 + 0.08*oven;
      const k = kPump + kLeak;

      lab.pressure += (desired - lab.pressure) * (1 - Math.exp(-k*dt));
      lab.pressure = Math.max(2e-12, lab.pressure);
    }

    function ovenUpdate(dt){
      const ambient = 24;
      const target = lab.ovenOn ? (ambient + 650*lab.ovenSet) : ambient;
      const tau = lab.ovenOn ? 1.8 : 3.2; // seconds
      lab.ovenTempC += (target - lab.ovenTempC)*(1 - Math.exp(-dt/tau));
    }

    function ionsUpdate(dt){
      const heatBg = 0.004 + 0.03*lab.ovenSet*(lab.ovenOn ? 1:0);
      const heat = heatBg + (ui.numHeat?.valueAsNumber || 0.03);
      const coolPower = lab.coolingOn ? 1.0 : 0.0;
      const coolRate = 0.30 * coolPower; // quanta/ms

      const dn = (heat - coolRate) * dt * 1e3; // dt in s -> ms
      lab.nbar = Math.max(0.02, lab.nbar + dn);

      // lose ions if pressure high
      if(lab.ionsLoaded > 0){
        const lossRate = clamp((lab.pressure - 1e-10)/(5e-10), 0, 1) * 0.4;
        if(Math.random() < lossRate*dt){
          lab.ionsLoaded = Math.max(0, lab.ionsLoaded - 1);
          lab.ions = lab.ions.slice(0, lab.ionsLoaded);
          log(`Ion lost (pressure event). Remaining: ${lab.ionsLoaded}`);
          toast('Ion lost (pressure event).');
        }
      }
    }

    function estimateWz(){
      const V = lab.rf.vpp;
      const f = lab.rf.fMHz;
      const wz = Math.sqrt(Math.max(0.01, (lab.trap.wzMHz*lab.trap.wzMHz) + 1e-4*(V-120) + 1e-3*(f-25)));
      return wz;
    }

    /********************
     * Program compiler (tiny DSL)
     * - Supports: Op [targets...] Duration
     * - Duration must be last token.
     * - Targets optional: q0 q1 ... or 0 1 ...
     ********************/
    const templates = {
      ramsey: [
        'Doppler 2ms',
        'OpticalPump 200us',
        'Pi/2 q0 10us',
        'Wait 50us',
        'Pi/2 q0 10us',
        'Readout 200us'
      ].join('\n'),
      bell: [
        'Doppler 2ms',
        'OpticalPump 200us',
        'Pi/2 q0 10us',
        'MS q0 q1 60us',
        'Readout 200us'
      ].join('\n'),
      ms: [
        'Doppler 2ms',
        'OpticalPump 200us',
        'MS q0 q1 60us',
        'Readout 250us'
      ].join('\n'),
      rabi: [
        'Doppler 2ms',
        'OpticalPump 200us',
        'Rabi q0 30us',
        'Readout 200us'
      ].join('\n'),
      readout: [
        'Readout 250us'
      ].join('\n'),
    };

    function parseDuration(tok){
      const m = String(tok).trim().match(/^([0-9]*\.?[0-9]+)\s*(us|µs|ms|s)$/i);
      if(!m) return null;
      const x = parseFloat(m[1]);
      const unit = m[2].toLowerCase();
      if(unit === 'us' || unit === 'µs') return x*1e-6;
      if(unit === 'ms') return x*1e-3;
      if(unit === 's') return x;
      return null;
    }

    function normalizeProgramText(text){
      let s = String(text ?? '');
      s = s.replace(/\r\n/g, '\n').replace(/\r/g, '\n');
      // If the text came in as a single line with literal "\n", convert it.
      if(!s.includes('\n') && s.includes('\\n')){
        s = s.replace(/\\n/g, '\n');
      }
      return s;
    }

    function parseTargets(argTokens){
      const targets = [];
      let all = false;
      for(const tok0 of (argTokens || [])){
        const tok = String(tok0).trim();
        if(!tok) continue;
        const parts = tok.split(',').map(s=>s.trim()).filter(Boolean);
        for(const p of parts){
          if(p === '*' || p.toLowerCase() === 'all'){
            all = true;
            continue;
          }
          const m = p.match(/^q?(\d+)$/i);
          if(m){
            targets.push(parseInt(m[1], 10));
            continue;
          }
          // ignore unknown tokens silently (keeps DSL forgiving), but you could also throw here
        }
      }
      return { all, targets };
    }

    function compileProgram(text){
      const normalized = normalizeProgramText(text);
      const rawLines = normalized.split('\n').map(s => s.trim());

      const ops = [];
      for(let i=0;i<rawLines.length;i++){
        const ln = rawLines[i];
        if(!ln) continue;

        // allow simple comment lines
        if(ln.startsWith('#') || ln.startsWith('//') || ln.startsWith(';')) continue;

        const parts = ln.split(/\s+/).filter(Boolean);
        const op = (parts[0] || '').toLowerCase();
        if(!op) continue;

        const needsDur = !['barrier','idle'].includes(op);
        let dur = 0;
        let argTokens = parts.slice(1);

        if(needsDur){
          if(parts.length < 2){
            throw new Error(`Missing duration on line ${i+1}: "${ln}" (use us/µs/ms/s)`);
          }
          const maybeDur = parseDuration(parts[parts.length-1]);
          if(maybeDur == null || !isFinite(maybeDur)){
            throw new Error(`Bad duration on line ${i+1}: "${ln}" (duration must be last token; use us/µs/ms/s)`);
          }
          dur = maybeDur;
          argTokens = parts.slice(1, -1);
        }

        const args = parseTargets(argTokens);
        ops.push({ op, dur, raw: ln, args });
      }
      return ops;
    }

    /********************
     * Proper stabilizer-tableau simulator (Clifford circuits)
     * - This fixes the root bug: entanglement/correlation now comes from real Clifford evolution.
     * - Based on Aaronson–Gottesman stabilizer tableau algorithms.
     ********************/
    function popcount32(x){
      x = x - ((x >>> 1) & 0x55555555);
      x = (x & 0x33333333) + ((x >>> 2) & 0x33333333);
      return (((x + (x >>> 4)) & 0x0F0F0F0F) * 0x01010101) >>> 24;
    }
    function parity32(x){ return popcount32(x) & 1; }

    // g(x1,z1,x2,z2) table (AG 2004)
    const G = [
      [0,0,0,0],
      [0,0,3,1],
      [0,1,0,3],
      [0,3,1,0],
    ];

    class TableauSim {
      constructor(n){
        if(n < 1 || n > 31) throw new Error('TableauSim supports 1..31 qubits (UI clamps to 16).');
        this.n = n;
        const rows = 2*n + 1; // + scratch
        this.x = new Uint32Array(rows);
        this.z = new Uint32Array(rows);
        this.r = new Uint8Array(rows);
        this.resetAll();
      }

      clone(){
        const t = new TableauSim(this.n);
        t.x.set(this.x);
        t.z.set(this.z);
        t.r.set(this.r);
        return t;
      }

      resetAll(){
        const n = this.n;
        // Destabilizers: X_i
        for(let i=0;i<n;i++){
          this.x[i] = (1 << i);
          this.z[i] = 0;
          this.r[i] = 0;
        }
        // Stabilizers: Z_i
        for(let i=0;i<n;i++){
          this.x[n+i] = 0;
          this.z[n+i] = (1 << i);
          this.r[n+i] = 0;
        }
        // Scratch
        this.x[2*n] = 0;
        this.z[2*n] = 0;
        this.r[2*n] = 0;
      }

      // Row sum: row[h] *= row[i]
      rowsum(h, i){
        let phase = (2*this.r[h] + 2*this.r[i]) & 3;
        let xh = this.x[h], zh = this.z[h];
        const xi = this.x[i], zi = this.z[i];

        let m = (xh | zh | xi | zi) >>> 0;
        while(m){
          const q = m & -m;
          m ^= q;

          const x1 = (xh & q) ? 1 : 0;
          const z1 = (zh & q) ? 1 : 0;
          const x2 = (xi & q) ? 1 : 0;
          const z2 = (zi & q) ? 1 : 0;

          const a = (x1 << 1) | z1; // 0..3
          const b = (x2 << 1) | z2; // 0..3
          phase = (phase + G[a][b]) & 3;
        }

        this.r[h] = (phase === 2) ? 1 : 0;
        this.x[h] = xh ^ xi;
        this.z[h] = zh ^ zi;
      }

      h(q){
        const m = (1 << q) >>> 0;
        for(let i=0;i<2*this.n;i++){
          const xq = (this.x[i] & m) ? 1 : 0;
          const zq = (this.z[i] & m) ? 1 : 0;
          if(xq && zq) this.r[i] ^= 1; // Y -> -Y
          if(xq !== zq){
            this.x[i] ^= m;
            this.z[i] ^= m;
          }
        }
      }

      s(q){
        const m = (1 << q) >>> 0;
        for(let i=0;i<2*this.n;i++){
          const xq = (this.x[i] & m) ? 1 : 0;
          const zq = (this.z[i] & m) ? 1 : 0;
          if(xq && zq) this.r[i] ^= 1;
          if(xq) this.z[i] ^= m;
        }
      }

      sdg(q){
        // S^\dagger = S^3
        this.s(q); this.s(q); this.s(q);
      }

      cnot(c, t){
        if(c === t) return;
        const cm = (1 << c) >>> 0;
        const tm = (1 << t) >>> 0;
        for(let i=0;i<2*this.n;i++){
          const x = this.x[i], z = this.z[i];
          const xc = (x & cm) ? 1 : 0;
          const zc = (z & cm) ? 1 : 0;
          const xt = (x & tm) ? 1 : 0;
          const zt = (z & tm) ? 1 : 0;

          if(xc && zt && ((xt ^ zc ^ 1) === 1)) this.r[i] ^= 1;
          if(xc) this.x[i] ^= tm;
          if(zt) this.z[i] ^= cm;
        }
      }

      cz(a, b){
        // CZ = H(b) CNOT(a,b) H(b)
        this.h(b);
        this.cnot(a, b);
        this.h(b);
      }

      applyPauli(xMask, zMask){
        // Left-multiply by Pauli operator on current state.
        for(let i=0;i<2*this.n;i++){
          const anticomm = parity32((this.x[i] & zMask) ^ (this.z[i] & xMask));
          if(anticomm) this.r[i] ^= 1;
        }
      }

      xGate(q){ this.applyPauli((1<<q)>>>0, 0); }
      zGate(q){ this.applyPauli(0, (1<<q)>>>0); }
      yGate(q){ this.applyPauli((1<<q)>>>0, (1<<q)>>>0); }

      measureZ(q){
        const n = this.n;
        const m = (1 << q) >>> 0;

        // Find stabilizer row with X on measured qubit
        let p = -1;
        for(let i=n; i<2*n; i++){
          if(this.x[i] & m){ p = i; break; }
        }

        if(p !== -1){
          // random outcome
          const outcome = (Math.random() < 0.5) ? 0 : 1;

          // eliminate other Xs in column q
          for(let i=0;i<2*n;i++){
            if(i !== p && (this.x[i] & m)){
              this.rowsum(i, p);
            }
          }

          // copy p to destabilizer partner
          const dp = p - n;
          this.x[dp] = this.x[p];
          this.z[dp] = this.z[p];
          this.r[dp] = this.r[p];

          // set p to Z generator with phase = outcome
          this.x[p] = 0;
          this.z[p] = m;
          this.r[p] = outcome ? 1 : 0;

          return outcome;
        }

        // deterministic outcome: compute from destabilizers
        const scratch = 2*n;
        this.x[scratch] = 0;
        this.z[scratch] = 0;
        this.r[scratch] = 0;

        for(let i=0;i<n;i++){
          if(this.x[i] & m){
            this.rowsum(scratch, n+i);
          }
        }
        const out = this.r[scratch] ? 1 : 0;
        this.x[scratch] = 0;
        this.z[scratch] = 0;
        this.r[scratch] = 0;
        return out;
      }
    }

    // Expose for debugging
    window.StabilizerTableau = TableauSim;

    /********************
     * Noise helpers (Pauli channels)
     ********************/
    function maybeApply1QDepol(sim, q, p){
      if(p <= 0) return;
      if(Math.random() >= p) return;
      const r = Math.random();
      if(r < 1/3) sim.xGate(q);
      else if(r < 2/3) sim.yGate(q);
      else sim.zGate(q);
    }

    function maybeApply2QDepol(sim, a, b, p){
      if(p <= 0) return;
      if(Math.random() >= p) return;
      // sample from 15 non-identity Paulis on {a,b}
      const paulis = [0,1,2,3]; // 0=I,1=X,2=Z,3=Y
      let p1 = 0, p2 = 0;
      do{
        p1 = paulis[(Math.random()*4)|0];
        p2 = paulis[(Math.random()*4)|0];
      }while(p1===0 && p2===0);

      const applyOne = (q, t) => {
        if(t===1) sim.xGate(q);
        else if(t===2) sim.zGate(q);
        else if(t===3) sim.yGate(q);
      };
      applyOne(a, p1);
      applyOne(b, p2);
    }

    function applyDephasing(sim, durS, T2ms, n){
      if(durS <= 0) return;
      const T2s = Math.max(1e-6, T2ms*1e-3);
      const pZ = 0.5 * (1 - Math.exp(-durS / T2s)); // Pauli-twirled dephasing
      for(let q=0;q<n;q++){
        if(Math.random() < pZ){
          sim.zGate(q);
        }
      }
    }

    function effectiveGateErrorParams(totalProgTimeS){
      const baseP1 = clamp(ui.numP1?.valueAsNumber || 0.006, 0, 1);
      const baseP2 = clamp(ui.numP2?.valueAsNumber || 0.002, 0, 1);

      const heat = Math.max(0, ui.numHeat?.valueAsNumber || 0.03); // q/ms
      const totalMs = totalProgTimeS * 1e3;

      // crude “during-run” nbar estimate: current n̄ plus half the heating over the program
      const nbarRun = Math.max(0.02, lab.nbar + 0.5*heat*totalMs);

      // micromotion penalty (0..~0.6)
      const mm = clamp(lab.mm.ratio || 0, 0, 1);

      // laser penalty: MS is most sensitive to 355 in this toy model
      const L355 = lab.lasers?.L355;
      const laserBad = (L355 && (!L355.lock || Math.abs(L355.err) > 0.5)) ? 1 : 0;
      const laserMag = clamp(Math.abs(L355?.err || 0), 0, 2);

      // motional penalty from n̄
      const mot = clamp(0.0015 * nbarRun, 0, 0.06);

      // final effective errors
      const p1 = clamp(baseP1 * (1 + 0.15*laserMag), 0, 1);
      const p2 = clamp(baseP2 * (1 + 0.9*mm) + mot + 0.004*laserBad, 0, 1);

      return { p1, p2, nbarRun };
    }

    /********************
     * Readout model
     ********************/
    function sampleCounts(bit, detT_us){
      const brightMu = ui.numBright?.valueAsNumber || 26;
      const darkMu   = ui.numDark?.valueAsNumber || 3;
      const depumpHz = ui.numDepump?.valueAsNumber || 700;
      const pumpHz   = ui.numPump?.valueAsNumber || 250;

      const t = detT_us / 200;
      let muB = brightMu * t;
      let muD = darkMu * t;

      const pBD = 1 - Math.exp(-(depumpHz)*(detT_us*1e-6));
      const pDB = 1 - Math.exp(-(pumpHz)*(detT_us*1e-6));

      if(bit === 1){
        const mix = pBD;
        const mu = (1-mix)*muB + mix*muD;
        return poisson(Math.max(0.05, mu));
      }else{
        const mix = pDB;
        const mu = (1-mix)*muD + mix*muB;
        return poisson(Math.max(0.05, mu));
      }
    }

    function classifyCount(k){
      const thr = ui.numThresh?.valueAsNumber || 12;
      const mode = (ui.selClassifier?.value || 'threshold').toLowerCase();
      if(mode === 'llr'){
        const llr = ui.rngLLR?.valueAsNumber || 0;
        return (k >= (thr + llr)) ? 1 : 0;
      }
      if(mode === 'naivebayes'){
        const s = 1/(1 + Math.exp(-(k - thr)/2));
        return (Math.random() < s) ? 1 : 0;
      }
      return (k >= thr) ? 1 : 0;
    }

    function addCrosstalk(bits, xtalk){
      if(bits.length <= 1) return bits;
      const out = bits.slice();
      for(let i=0;i<bits.length;i++){
        if(bits[i] === 1){
          if(i>0 && Math.random() < xtalk*0.5) out[i-1] = 1;
          if(i<bits.length-1 && Math.random() < xtalk*0.5) out[i+1] = 1;
        }
      }
      return out;
    }

    /********************
     * Target resolution (defaults preserve old “minimal line” programs)
     ********************/
    function resolve1QTargets(opObj, n){
      const a = opObj?.args;
      if(a?.all) return [...Array(n)].map((_,i)=>i);
      const t = (a?.targets || []).filter(Number.isFinite);
      if(t.length) return t.map(q => clamp(q,0,n-1)|0);
      return [0]; // default
    }

    function resolve2QPairs(opObj, n){
      const a = opObj?.args;
      const t = (a?.targets || []).filter(Number.isFinite).map(q=>clamp(q,0,n-1)|0);

      // "all" => apply to adjacent pairs
      if(a?.all){
        const pairs = [];
        for(let i=0;i<n-1;i++) pairs.push([i,i+1]);
        return pairs.length ? pairs : [[0,0]];
      }

      if(t.length >= 2) return [[t[0], t[1]]];
      if(t.length === 1){
        const c = t[0];
        const d = (c+1 < n) ? (c+1) : c;
        return [[c, d]];
      }
      if(n >= 2) return [[0,1]];
      return [[0,0]];
    }

    /********************
     * Run shots (real stabilizer simulation + per-shot noise + readout)
     ********************/
    function runShots(ops){
      const n = clamp(ui.numQ?.valueAsNumber || 4, 1, 16) | 0;
      const shots = clamp(ui.numShots?.valueAsNumber || 2000, 1, 50000) | 0;
      const xtalk = clamp(ui.numXtalk?.valueAsNumber || 0.05, 0, 1);

      // Ensure ion chain exists (UX: auto-load to match run settings)
      if(lab.ionsLoaded !== n){
        lab.ionsLoaded = n;
        lab.ions = makeIonChain(n);
        log(`Auto-load: matched hardware ion count to n=${n}`);
      }

      const progT = ops.reduce((s,o)=>s+o.dur,0);
      const T2ms = Math.max(0.1, ui.numT2?.valueAsNumber || 25);
      const { p1, p2 } = effectiveGateErrorParams(progT);

      // If there is a readout op, we stop there (readout ends experiment)
      const lastRead = [...ops].map(o=>o.op).lastIndexOf('readout');
      const unitaryOps = (lastRead >= 0) ? ops.slice(0, lastRead) : ops;
      const readoutDur = (lastRead >= 0) ? ops[lastRead].dur : 0;

      const detT_us = ui.numDetT?.valueAsNumber || 200;
      const sensor = (ui.selSensor?.value || 'pmts').toLowerCase();

      const outcomeCounts = new Map();
      const brightCounts = [];
      const darkCounts = [];

      let totalErr = 0;

      for(let s=0; s<shots; s++){
        const sim = new TableauSim(n);

        // Run program up to readout
        for(const o of unitaryOps){
          // time-based dephasing during any step that takes time
          applyDephasing(sim, o.dur, T2ms, n);

          const op = o.op;

          if(op === 'doppler'){
            // No internal (qubit) effect here; motion is tracked separately via n̄.
            continue;
          }
          if(op === 'opticalpump' || op === 'reset'){
            sim.resetAll();
            continue;
          }
          if(op === 'wait' || op === 'idle' || op === 'barrier'){
            continue;
          }

          // 1-qubit gates
          if(op === 'pi/2' || op === 'h'){
            const qs = resolve1QTargets(o, n);
            for(const q of qs){
              sim.h(q);
              maybeApply1QDepol(sim, q, p1);
            }
            continue;
          }
          if(op === 's'){
            const qs = resolve1QTargets(o, n);
            for(const q of qs){
              sim.s(q);
              maybeApply1QDepol(sim, q, p1);
            }
            continue;
          }
          if(op === 'sdg'){
            const qs = resolve1QTargets(o, n);
            for(const q of qs){
              sim.sdg(q);
              maybeApply1QDepol(sim, q, p1);
            }
            continue;
          }
          if(op === 'pi' || op === 'x' || op === 'rabi'){
            const qs = resolve1QTargets(o, n);
            for(const q of qs){
              sim.xGate(q);
              maybeApply1QDepol(sim, q, p1);
            }
            continue;
          }
          if(op === 'z'){
            const qs = resolve1QTargets(o, n);
            for(const q of qs){
              sim.zGate(q);
              maybeApply1QDepol(sim, q, p1);
            }
            continue;
          }

          // 2-qubit gates
          if(op === 'ms' || op === 'cnot'){
            const pairs = resolve2QPairs(o, n);
            for(const [c,t] of pairs){
              sim.cnot(c,t);     // MS modeled as circuit-level entangler
              maybeApply2QDepol(sim, c, t, p2);
            }
            continue;
          }
          if(op === 'cz'){
            const pairs = resolve2QPairs(o, n);
            for(const [a,b] of pairs){
              sim.cz(a,b);
              maybeApply2QDepol(sim, a, b, p2);
            }
            continue;
          }

          // unknown op: ignore (or you can throw)
        }

        // dephasing during readout window before measurement
        applyDephasing(sim, readoutDur, T2ms, n);

        // Ideal projective measurement in Z basis
        const ideal = new Array(n);
        for(let q=0;q<n;q++){
          ideal[q] = sim.measureZ(q);
        }

        // Photon-count readout model
        const counts = new Array(n);
        for(let i=0;i<n;i++){
          counts[i] = sampleCounts(ideal[i], detT_us);
          if(ideal[i] === 1) brightCounts.push(counts[i]); else darkCounts.push(counts[i]);
        }

        let measured = counts.map(classifyCount);
        measured = addCrosstalk(measured, xtalk);

        if(sensor === 'camera'){
          lab.cam.lastCounts = counts.slice();
        }

        for(let i=0;i<n;i++){
          if(measured[i] !== ideal[i]) totalErr++;
        }

        const bits = measured.map(b=>b?1:0).join('');
        outcomeCounts.set(bits, (outcomeCounts.get(bits)||0) + 1);
      }

      const spam = totalErr / (shots*n);
      lab.readout.lastSpam = spam;
      lab.readout.lastBrightCounts = brightCounts;
      lab.readout.lastDarkCounts = darkCounts;

      const outcomes = [...outcomeCounts.entries()]
        .map(([bits, c]) => ({bits, c, p: c/shots}))
        .sort((a,b)=> b.c - a.c);

      renderDistributionTable(outcomes);
      drawDist(outcomes);
      drawReadout(brightCounts, darkCounts);

      if(sensor === 'camera'){
        makeCameraFrameFromCounts(lab.cam.lastCounts || new Array(n).fill(0));
      }

      const msg = `Run: n=${n}, shots=${shots}, T≈${(progT*1e3).toFixed(2)} ms, SPAM≈${(spam*100).toFixed(2)}%`;
      log(msg);
      toast(msg);
    }

    function makeIonChain(n){
      const xs = [];
      const spacing = 1;
      const mid = (n-1)/2;
      for(let i=0;i<n;i++) xs.push((i-mid)*spacing);
      return xs.map((x,i)=>({x, y:0, i}));
    }

    /********************
     * Camera frame synthesis
     ********************/
    function gaussian2D(x,y,s){
      const ss = s*s;
      return Math.exp(-(x*x + y*y)/(2*ss));
    }

    function makeCameraFrameFromCounts(counts){
      const ctx = ensureCanvas(ui.cvCam);
      if(!ctx) return;

      const n = counts.length;
      const w = ctx.canvas.width;
      const h = ctx.canvas.height;

      const img = new Float32Array(w*h);
      img.fill(0);

      const sigma = lab.cam.sigma;
      const gain = lab.cam.gain;

      const cx = w*0.5;
      const cy = h*0.52;
      const pitch = Math.min(w,h) / Math.max(10, n+2);

      const xs = [];
      for(let i=0;i<n;i++){
        xs.push(cx + (i - (n-1)/2)*pitch);
      }

      for(let i=0;i<n;i++){
        const amp = gain * (counts[i] || 0);
        const xi = xs[i];
        const yi = cy;
        const r = Math.ceil(4*sigma);
        const x0 = Math.max(0, Math.floor(xi - r));
        const x1 = Math.min(w-1, Math.floor(xi + r));
        const y0 = Math.max(0, Math.floor(yi - r));
        const y1 = Math.min(h-1, Math.floor(yi + r));
        for(let yy=y0; yy<=y1; yy++){
          for(let xx=x0; xx<=x1; xx++){
            img[yy*w + xx] += amp * gaussian2D(xx-xi, yy-yi, sigma);
          }
        }
      }

      // background + mild camera noise
      for(let i=0;i<img.length;i++){
        img[i] += 2 + 0.12*Math.abs(randn());
      }

      // centroid in ROI (optional)
      const roiHalf = Math.max(4, lab.cam.roiHalf|0);
      const roiX0 = Math.max(0, (cx - roiHalf)|0);
      const roiX1 = Math.min(w-1, (cx + roiHalf)|0);
      const roiY0 = Math.max(0, (cy - roiHalf)|0);
      const roiY1 = Math.min(h-1, (cy + roiHalf)|0);

      let sI=0, sX=0, sY=0;
      for(let yy=roiY0; yy<=roiY1; yy++){
        for(let xx=roiX0; xx<=roiX1; xx++){
          const v = img[yy*w+xx];
          sI += v;
          sX += v*xx;
          sY += v*yy;
        }
      }
      lab.cam.centroid = (sI>0) ? {x:sX/sI, y:sY/sI} : null;

      lab.cam.lastImage = img;
    }

    /********************
     * Renderers
     ********************/
    function drawVacuum(){
      const ctx = ensureCanvas(ui.cvEnv);
      if(!ctx) return;
      clear(ctx);
      axes(ctx, 'Vacuum / Oven');

      const c = ctx.canvas;
      const p = lab.pressure;
      const logp = Math.log10(p);
      const lo = -12, hi = -8;
      const x = map(clamp(logp, lo, hi), lo, hi, 20, c.width-20);

      ctx.save();
      ctx.strokeStyle = 'rgba(255,255,255,.22)';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(20, c.height*0.55);
      ctx.lineTo(c.width-20, c.height*0.55);
      ctx.stroke();

      ctx.fillStyle = 'rgba(255,255,255,.55)';
      ctx.font = `12px ${getComputedStyle(document.body).fontFamily}`;
      for(let L=-12; L<=-8; L++){
        const xx = map(L, lo, hi, 20, c.width-20);
        ctx.globalAlpha = 0.50;
        ctx.beginPath();
        ctx.moveTo(xx, c.height*0.55-8);
        ctx.lineTo(xx, c.height*0.55+8);
        ctx.stroke();
        ctx.globalAlpha = 0.9;
        ctx.fillText(`1e${L}`, xx-14, c.height*0.55+26);
      }

      const col = (p < 3e-11) ? COLORS.ok : (p < 2e-10) ? COLORS.warn : COLORS.bad;
      ctx.strokeStyle = col;
      ctx.lineWidth = 4;
      ctx.beginPath();
      ctx.moveTo(x, c.height*0.55-18);
      ctx.lineTo(x, c.height*0.55+18);
      ctx.stroke();

      const temp = lab.ovenTempC;
      const t0 = 20, t1 = 700;
      const frac = clamp((temp - t0)/(t1-t0), 0, 1);
      const barW = (c.width-40)*frac;
      ctx.fillStyle = 'rgba(255,210,123,.20)';
      ctx.fillRect(20, c.height*0.74, barW, 10);
      ctx.strokeStyle = 'rgba(255,255,255,.15)';
      ctx.strokeRect(20, c.height*0.74, c.width-40, 10);
      ctx.fillStyle = 'rgba(255,255,255,.65)';
      ctx.fillText(`Oven ${temp.toFixed(0)} °C`, 20, c.height*0.74-6);

      ctx.restore();
    }

    function drawIons(){
      const ctx = ensureCanvas(ui.cvIons);
      if(!ctx) return;
      clear(ctx);
      axes(ctx, 'Ion Chain');

      const c = ctx.canvas;
      const ions = lab.ions || [];
      const n = ions.length;

      const y = c.height*0.55;
      const left = 30, right = c.width-30;

      ctx.save();
      ctx.strokeStyle = 'rgba(255,255,255,.16)';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(left, y);
      ctx.lineTo(right, y);
      ctx.stroke();

      if(n === 0){
        ctx.fillStyle = 'rgba(255,255,255,.55)';
        ctx.font = `14px ${getComputedStyle(document.body).fontFamily}`;
        ctx.fillText('No ions loaded.', left, y-18);
        ctx.restore();
        return;
      }

      for(let i=0;i<n;i++){
        const x = map(i, 0, Math.max(1,n-1), left, right);
        const b = Math.exp(-lab.nbar/6);
        const r = 10;

        ctx.beginPath();
        ctx.fillStyle = `rgba(47,227,154,${0.25 + 0.55*b})`;
        ctx.arc(x,y,r,0,Math.PI*2);
        ctx.fill();

        ctx.strokeStyle = 'rgba(255,255,255,.12)';
        ctx.stroke();

        ctx.fillStyle = 'rgba(255,255,255,.65)';
        ctx.font = `12px ${getComputedStyle(document.body).fontFamily}`;
        ctx.fillText(`${i}`, x-3, y+28);
      }

      ctx.restore();
    }

    function drawPulseTimeline(ops){
      const ctx = ensureCanvas(ui.cvPulse);
      if(!ctx) return;
      clear(ctx);
      axes(ctx, 'Pulse Timeline');

      const c = ctx.canvas;
      ctx.save();

      if(!ops || ops.length === 0){
        ctx.fillStyle = 'rgba(255,255,255,.55)';
        ctx.font = `14px ${getComputedStyle(document.body).fontFamily}`;
        ctx.fillText('No compiled program.', 12, 50);
        ctx.restore();
        return;
      }

      const total = ops.reduce((s,o)=>s+o.dur,0);
      const x0 = 20, x1 = c.width-20;
      const y0 = 55, h = c.height-70;
      let t = 0;

      for(const o of ops){
        const a = (total>0) ? (t/total) : 0;
        const b = (total>0) ? ((t+o.dur)/total) : 0;
        const xx0 = map(a,0,1,x0,x1);
        const xx1 = map(b,0,1,x0,x1);

        const op = o.op;
        const isRead = op === 'readout';
        const isCool = (op==='doppler' || op==='opticalpump');
        const isGate = ['pi','pi/2','ms','rabi','x','h','s','sdg','cnot','cz','z'].includes(op);
        const col = isRead ? 'rgba(123,221,255,.35)'
                  : isCool ? 'rgba(255,210,123,.22)'
                  : isGate ? 'rgba(47,227,154,.22)'
                  : 'rgba(255,255,255,.12)';

        ctx.fillStyle = col;
        ctx.fillRect(xx0, y0, Math.max(1, xx1-xx0), h);
        ctx.strokeStyle = 'rgba(255,255,255,.12)';
        ctx.strokeRect(xx0, y0, Math.max(1, xx1-xx0), h);

        ctx.save();
        ctx.translate((xx0+xx1)/2, y0 + h/2);
        ctx.rotate(-Math.PI/2);
        ctx.fillStyle = 'rgba(255,255,255,.78)';
        ctx.font = `12px ${getComputedStyle(document.body).fontFamily}`;
        ctx.textAlign = 'center';
        ctx.fillText(o.raw, 0, 4);
        ctx.restore();

        t += o.dur;
      }

      ctx.fillStyle = 'rgba(255,255,255,.65)';
      ctx.font = `12px ${getComputedStyle(document.body).fontFamily}`;
      ctx.fillText(`Total ${(total*1e3).toFixed(2)} ms`, 20, c.height-14);

      ctx.restore();
    }

    function drawReadout(brightCounts, darkCounts){
      const ctx = ensureCanvas(ui.cvReadout);
      if(!ctx) return;

      clear(ctx);
      axes(ctx, 'Readout Histogram');

      const c = ctx.canvas;
      ctx.save();

      if(lab.readout.lastSpam != null){
        ui.txtSpam.textContent = `${(lab.readout.lastSpam*100).toFixed(2)}%`;
      }else{
        ui.txtSpam.textContent = '—';
      }

      const detT = ui.numDetT?.valueAsNumber || 200;
      const muB = (ui.numBright?.valueAsNumber || 26) * (detT/200);
      const muD = (ui.numDark?.valueAsNumber || 3) * (detT/200);
      const thr = ui.numThresh?.valueAsNumber || 12;
      ui.txtCountsPhysical.innerHTML = `Pois(μ<sub>b</sub>≈${muB.toFixed(1)}), Pois(μ<sub>d</sub>≈${muD.toFixed(1)}), thr=${thr}`;

      if(!brightCounts?.length && !darkCounts?.length){
        ctx.fillStyle = 'rgba(255,255,255,.55)';
        ctx.font = `14px ${getComputedStyle(document.body).fontFamily}`;
        ctx.fillText('Run shots to populate histogram.', 12, 52);
        ctx.restore();
        return;
      }

      const all = brightCounts.concat(darkCounts);
      const maxC = Math.max(10, ...all);
      const bins = Math.min(40, Math.max(12, Math.floor(c.width/24)));
      const binW = maxC / bins;

      function hist(arr){
        const h = new Array(bins).fill(0);
        for(const k of arr){
          const i = Math.min(bins-1, Math.floor(k/binW));
          h[i]++;
        }
        return h;
      }

      const hb = hist(brightCounts);
      const hd = hist(darkCounts);
      const ymax = Math.max(1, ...hb, ...hd);

      const px0 = 20, px1 = c.width-20;
      const py0 = 48, py1 = c.height-20;

      const tx = map(thr, 0, maxC, px0, px1);
      ctx.strokeStyle = 'rgba(255,255,255,.35)';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(tx, py0);
      ctx.lineTo(tx, py1);
      ctx.stroke();

      for(let i=0;i<bins;i++){
        const x0 = map(i, 0, bins, px0, px1);
        const x1 = map(i+1, 0, bins, px0, px1);
        const yb = map(hb[i], 0, ymax, py1, py0);
        const yd = map(hd[i], 0, ymax, py1, py0);

        ctx.fillStyle = 'rgba(255,107,107,.28)';
        ctx.fillRect(x0, yd, Math.max(1, x1-x0-1), py1-yd);

        ctx.fillStyle = 'rgba(47,227,154,.26)';
        ctx.fillRect(x0, yb, Math.max(1, x1-x0-1), py1-yb);
      }

      ctx.fillStyle = 'rgba(255,255,255,.65)';
      ctx.font = `12px ${getComputedStyle(document.body).fontFamily}`;
      ctx.fillText('dark', 24, 42);
      ctx.fillText('bright', 70, 42);

      ctx.restore();
    }

    function drawDist(outcomes){
      const ctx = ensureCanvas(ui.cvDist);
      if(!ctx) return;

      clear(ctx);
      axes(ctx, 'Outcome Distribution');

      const c = ctx.canvas;
      ctx.save();

      if(!outcomes || outcomes.length === 0){
        ctx.fillStyle = 'rgba(255,255,255,.55)';
        ctx.font = `14px ${getComputedStyle(document.body).fontFamily}`;
        ctx.fillText('Run shots to populate distribution.', 12, 52);
        ctx.restore();
        return;
      }

      const top = outcomes.slice(0, Math.min(16, outcomes.length));
      const ymax = Math.max(...top.map(o=>o.p));
      const px0 = 20, px1 = c.width-20;
      const py0 = 48, py1 = c.height-20;

      for(let i=0;i<top.length;i++){
        const o = top[i];
        const x0 = map(i, 0, top.length, px0, px1);
        const x1 = map(i+1, 0, top.length, px0, px1);
        const y = map(o.p, 0, ymax, py1, py0);

        ctx.fillStyle = 'rgba(123,221,255,.28)';
        ctx.fillRect(x0, y, Math.max(2, x1-x0-2), py1-y);

        ctx.fillStyle = 'rgba(255,255,255,.75)';
        ctx.font = `12px ${getComputedStyle(document.body).fontFamily}`;
        ctx.save();
        ctx.translate((x0+x1)/2, py1+14);
        ctx.rotate(-Math.PI/6);
        ctx.textAlign = 'center';
        ctx.fillText(o.bits, 0, 0);
        ctx.restore();
      }

      ctx.fillStyle = 'rgba(255,255,255,.65)';
      ctx.font = `12px ${getComputedStyle(document.body).fontFamily}`;
      ctx.fillText(`Top ${top.length}`, 20, 42);

      ctx.restore();
    }

    function drawCamera(){
      const ctx = ensureCanvas(ui.cvCam);
      if(!ctx) return;

      clear(ctx);
      axes(ctx, 'Camera');

      const c = ctx.canvas;
      ctx.save();

      const img = lab.cam.lastImage;
      if(!img){
        ctx.fillStyle = 'rgba(255,255,255,.55)';
        ctx.font = `14px ${getComputedStyle(document.body).fontFamily}`;
        ctx.fillText('Run with Sensor=Camera to render a frame.', 12, 52);
        ctx.restore();
        return;
      }

      const w = c.width, h = c.height;

      let vmax = 0;
      for(let i=0;i<img.length;i++) vmax = Math.max(vmax, img[i]);
      vmax = Math.max(1, vmax);

      const imageData = ctx.createImageData(w,h);
      for(let i=0;i<w*h;i++){
        const v = Math.floor(255 * clamp(img[i]/vmax, 0, 1));
        imageData.data[4*i+0] = v;
        imageData.data[4*i+1] = v;
        imageData.data[4*i+2] = v;
        imageData.data[4*i+3] = 255;
      }
      ctx.putImageData(imageData, 0, 0);

      const cx = w*0.5;
      const cy = h*0.52;
      const roiHalf = Math.max(4, lab.cam.roiHalf|0);

      if(lab.cam.overlay === 'roi'){
        ctx.strokeStyle = 'rgba(255,255,255,.55)';
        ctx.lineWidth = 2;
        ctx.strokeRect(cx-roiHalf, cy-roiHalf, 2*roiHalf, 2*roiHalf);
      }
      if(lab.cam.overlay === 'centroid' && lab.cam.centroid){
        const p = lab.cam.centroid;
        ctx.strokeStyle = 'rgba(47,227,154,.85)';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(p.x-10, p.y);
        ctx.lineTo(p.x+10, p.y);
        ctx.moveTo(p.x, p.y-10);
        ctx.lineTo(p.x, p.y+10);
        ctx.stroke();
      }

      ctx.restore();
    }

    function drawLaserDiag(){
      const ctx = ensureCanvas(ui.cvLaser);
      if(!ctx) return;
      clear(ctx);
      axes(ctx, 'Laser Error (arb)');

      const c = ctx.canvas;
      const keys = ['L369','L399','L935','L355','L638'];
      const errs = keys.map(k=> lab.lasers[k].err);
      const ymax = Math.max(1e-6, ...errs.map(e=>Math.abs(e)));

      const px0=20, px1=c.width-20;
      const py0=48, py1=c.height-18;

      ctx.save();
      for(let i=0;i<keys.length;i++){
        const k = keys[i];
        const e = lab.lasers[k].err;
        const x0 = map(i,0,keys.length,px0,px1);
        const x1 = map(i+1,0,keys.length,px0,px1);
        const yMid = (py0+py1)/2;
        const y = map(e, -ymax, ymax, py1, py0);

        ctx.strokeStyle = 'rgba(255,255,255,.12)';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(x0+6, yMid);
        ctx.lineTo(x1-6, yMid);
        ctx.stroke();

        ctx.strokeStyle = lab.lasers[k].lock ? 'rgba(47,227,154,.8)' : 'rgba(255,107,107,.85)';
        ctx.lineWidth = 6;
        ctx.beginPath();
        ctx.moveTo((x0+x1)/2, yMid);
        ctx.lineTo((x0+x1)/2, y);
        ctx.stroke();

        ctx.fillStyle='rgba(255,255,255,.75)';
        ctx.font = `12px ${getComputedStyle(document.body).fontFamily}`;
        ctx.textAlign='center';
        ctx.fillText(k.replace('L',''), (x0+x1)/2, py1+14);
      }
      ctx.restore();
    }

    function drawMM(){
      const ctx = ensureCanvas(ui.cvMM);
      if(!ctx) return;
      clear(ctx);
      axes(ctx, 'Micromotion Sideband');

      const c = ctx.canvas;
      ctx.save();

      const dx = lab.mm.compX;
      const dy = lab.mm.compY;
      const r = Math.sqrt(dx*dx + dy*dy);

      lab.mm.amp = 0.10 + 0.85*(1 - Math.exp(-r*r/0.20));
      lab.mm.ratio = 0.02 + 0.60*(1 - Math.exp(-r*r/0.15));

      ui.txtMMamp.textContent = lab.mm.amp.toFixed(3);
      ui.txtMMratio.textContent = lab.mm.ratio.toFixed(3);

      const px0=20, px1=c.width-20;
      const py0=50, py1=c.height-18;

      const frac = clamp(lab.mm.ratio,0,1);
      const w = (px1-px0)*frac;
      ctx.fillStyle='rgba(255,210,123,.25)';
      ctx.fillRect(px0, (py0+py1)/2-8, w, 16);
      ctx.strokeStyle='rgba(255,255,255,.15)';
      ctx.strokeRect(px0, (py0+py1)/2-8, (px1-px0), 16);

      ctx.fillStyle='rgba(255,255,255,.70)';
      ctx.font = `12px ${getComputedStyle(document.body).fontFamily}`;
      ctx.fillText(`SB ratio ≈ ${(lab.mm.ratio*100).toFixed(1)}%`, px0, py0+10);

      ctx.restore();
    }

    function drawCalibration(){
      const ctx = ensureCanvas(ui.cvCal);
      if(!ctx) return;
      clear(ctx);
      axes(ctx, 'Calibration Plot');

      const c = ctx.canvas;
      ctx.save();

      const pts = lab.cal.points || [];
      if(pts.length === 0){
        ctx.fillStyle = 'rgba(255,255,255,.55)';
        ctx.font = `14px ${getComputedStyle(document.body).fontFamily}`;
        ctx.fillText('No calibration data.', 12, 52);
        ctx.restore();
        return;
      }

      const xs = pts.map(p=>p.x);
      const ys = pts.map(p=>p.y);
      const xmin = Math.min(...xs), xmax = Math.max(...xs);
      const ymin = Math.min(...ys), ymax = Math.max(...ys);

      const px0=30, px1=c.width-20;
      const py0=50, py1=c.height-20;

      ctx.strokeStyle='rgba(255,255,255,.15)';
      ctx.lineWidth=2;
      ctx.beginPath();
      ctx.moveTo(px0, py1);
      ctx.lineTo(px1, py1);
      ctx.moveTo(px0, py1);
      ctx.lineTo(px0, py0);
      ctx.stroke();

      ctx.fillStyle='rgba(123,221,255,.85)';
      for(const p of pts){
        const x = map(p.x, xmin, xmax, px0, px1);
        const y = map(p.y, ymin, ymax, py1, py0);
        ctx.beginPath();
        ctx.arc(x,y,4,0,Math.PI*2);
        ctx.fill();
      }

      ctx.fillStyle='rgba(255,255,255,.65)';
      ctx.font = `12px ${getComputedStyle(document.body).fontFamily}`;
      ctx.fillText(`n=${pts.length}`, px0, py0+12);

      ctx.restore();
    }

    function drawPhotonTrace(){
      const ctx = ensureCanvas(ui.cvPhoton);
      if(!ctx) return;
      clear(ctx);
      axes(ctx, 'Photon Trace (toy)');

      const c = ctx.canvas;
      ctx.save();

      const px0=20, px1=c.width-20;
      const py0=48, py1=c.height-20;

      const N=200;
      ctx.strokeStyle='rgba(123,221,255,.55)';
      ctx.lineWidth=2;

      ctx.beginPath();
      for(let i=0;i<N;i++){
        const x = map(i,0,N-1,px0,px1);
        const t = lab.t + i*0.02;
        const p = Math.log10(lab.pressure);
        const yBase = 0.55 + 0.18*Math.sin(2*Math.PI*0.22*t) + 0.10*Math.sin(2*Math.PI*0.07*t + 1.4);
        const yNoise = (0.06 + 0.02*lab.nbar) * randn() * 0.12;
        const y = clamp(yBase + yNoise + 0.04*(p+10), 0.08, 0.92);
        const yy = map(y,0,1,py1,py0);
        if(i===0) ctx.moveTo(x,yy); else ctx.lineTo(x,yy);
      }
      ctx.stroke();

      ctx.fillStyle='rgba(255,255,255,.65)';
      ctx.font = `12px ${getComputedStyle(document.body).fontFamily}`;
      ctx.fillText(`pressure=${lab.pressure.toExponential(2)} mbar`, px0, py0+12);

      ctx.restore();
    }

    function drawMS(){
      const ctx = ensureCanvas(ui.cvMS);
      if(!ctx) return;
      clear(ctx);
      axes(ctx, 'MS Diagnostic');

      const c = ctx.canvas;
      ctx.save();

      const ops = lab.program.compiled || [];
      const msOp = [...ops].reverse().find(o => o.op === 'ms');
      const px0=20, px1=c.width-20;
      const py0=48, py1=c.height-20;

      ctx.strokeStyle = 'rgba(255,255,255,.10)';
      ctx.lineWidth = 1;
      for(let k=0;k<=6;k++){
        const y = map(k,0,6,py0,py1);
        ctx.beginPath(); ctx.moveTo(px0,y); ctx.lineTo(px1,y); ctx.stroke();
      }

      if(!msOp){
        ctx.fillStyle = 'rgba(255,255,255,.55)';
        ctx.font = `14px ${getComputedStyle(document.body).fontFamily}`;
        ctx.fillText('No MS pulse in program. Add “MS 60us” to visualize.', 12, 72);
        ctx.restore();
        return;
      }

      // Heuristic: show a phase-space loop with closure depending on duration vs an arbitrary detuning
      const tGate = msOp.dur;               // seconds
      const delta = 12e3;                   // Hz (toy)
      const phase = 2*Math.PI*delta*tGate;  // rad
      const closure = Math.abs(Math.sin(phase/2)); // 0..1
      const fidelityProxy = clamp(1 - 0.9*closure - 0.06*lab.nbar/10, 0, 1);

      const cx = (px0+px1)*0.40;
      const cy = (py0+py1)*0.56;
      const R = Math.min(px1-px0, py1-py0)*0.22;

      // axes
      ctx.strokeStyle='rgba(255,255,255,.25)';
      ctx.lineWidth=2;
      ctx.beginPath(); ctx.moveTo(cx-R*1.6, cy); ctx.lineTo(cx+R*1.6, cy); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(cx, cy-R*1.6); ctx.lineTo(cx, cy+R*1.6); ctx.stroke();

      // loop
      ctx.strokeStyle='rgba(123,221,255,.85)';
      ctx.lineWidth=2;
      ctx.beginPath();
      const N=180;
      for(let i=0;i<=N;i++){
        const tt = (i/N)*tGate;
        const ph = 2*Math.PI*delta*tt;
        const aRe = (1 - Math.cos(ph));
        const aIm = (-Math.sin(ph));
        const x = cx + aRe*R;
        const y = cy - aIm*R;
        if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
      }
      ctx.stroke();

      // endpoint
      const aReE = (1 - Math.cos(phase));
      const aImE = (-Math.sin(phase));
      ctx.fillStyle='rgba(255,210,123,.95)';
      ctx.beginPath(); ctx.arc(cx + aReE*R, cy - aImE*R, 4, 0, Math.PI*2); ctx.fill();

      // info box
      const bx = (px0+px1)*0.62;
      const by = py0 + 10;
      ctx.fillStyle='rgba(0,0,0,.35)';
      ctx.fillRect(bx, by, (px1-bx), (py1-by));
      ctx.strokeStyle='rgba(255,255,255,.12)';
      ctx.strokeRect(bx, by, (px1-bx), (py1-by));

      ctx.fillStyle='rgba(232,240,251,.92)';
      ctx.font = `12px ${getComputedStyle(document.body).fontFamily}`;
      const line = (s, y) => ctx.fillText(s, bx+10, y);
      line(`MS dur: ${(tGate*1e6).toFixed(1)} µs`, by+24);
      line(`δ (toy): ${(delta/1e3).toFixed(1)} kHz`, by+44);
      line(`closure: ${closure.toFixed(3)}`, by+64);
      line(`fid. proxy: ${(100*fidelityProxy).toFixed(1)}%`, by+84);
      line(`n̄: ${lab.nbar.toFixed(2)}`, by+104);

      ctx.restore();
    }

    /********************
     * Tables
     ********************/
    function renderDistributionTable(outcomes){
      ui.tblOut.innerHTML = '';
      const top = outcomes.slice(0, 10);
      for(const o of top){
        const tr = document.createElement('tr');
        const tdBits = document.createElement('td');
        const tdP = document.createElement('td');
        const tdN = document.createElement('td');
        tdBits.textContent = o.bits;
        tdP.textContent = o.p.toFixed(4);
        tdN.textContent = o.c.toString();
        tr.appendChild(tdBits);
        tr.appendChild(tdP);
        tr.appendChild(tdN);
        ui.tblOut.appendChild(tr);
      }
    }

    function setCalRows(rows){
      ui.tblCal.innerHTML = '';
      for(const r of rows){
        const tr = document.createElement('tr');
        for(const key of ['type','x','y','note']){
          const td = document.createElement('td');
          td.textContent = (r[key] ?? '').toString();
          tr.appendChild(td);
        }
        ui.tblCal.appendChild(tr);
      }
    }

    /********************
     * UI bindings & navigation
     ********************/
    function setReady(kind, msg){
      // kind: 'ok'|'warn'|'bad'
      const col = (kind==='ok') ? COLORS.ok : (kind==='bad') ? COLORS.bad : COLORS.warn;
      ui.dotReady.style.background = col;
      ui.dotReady.style.boxShadow = (kind==='ok')
        ? '0 0 12px rgba(47,227,154,.35)'
        : (kind==='bad')
          ? '0 0 12px rgba(255,107,107,.35)'
          : '0 0 12px rgba(255,210,123,.35)';
      ui.readyTxt.textContent = msg;
      ui.cardState.textContent = msg;
    }

    function syncToggles(){
      const set = (btn, on) => {
        if(!btn) return;
        btn.setAttribute('aria-pressed', on ? 'true' : 'false');
      };
      set(ui.btnPump, lab.pumpOn);
      set(ui.btnBake, lab.bakeOn);
      set(ui.btnOven, lab.ovenOn);
      set(ui.btnCool, lab.coolingOn);

      // quick actions mirror
      set(ui.qaPump, lab.pumpOn);
      set(ui.qaBake, lab.bakeOn);
      set(ui.qaOven, lab.ovenOn);
      set(ui.qaCool, lab.coolingOn);
    }

    function syncText(){
      ui.txtPump.textContent = String(Math.round(lab.pumpSpeed*100));
      ui.txtOvenSet.textContent = String(Math.round(lab.ovenSet*100));
      ui.txtLLR.textContent = (ui.rngLLR?.valueAsNumber || 0).toFixed(1);
      ui.txtCamGain.textContent = (lab.cam.gain).toFixed(1);
      ui.txtCamSigma.textContent = (lab.cam.sigma).toFixed(1);

      ui.kvPressure.textContent = `${lab.pressure.toExponential(2)} mbar`;
      ui.kvOven.textContent = `${lab.ovenTempC.toFixed(0)} °C`;
      ui.kvRF.textContent = `${lab.rf.fMHz.toFixed(1)} MHz @ ${lab.rf.vpp.toFixed(0)} Vpp`;
      ui.kvWz.textContent = `${estimateWz().toFixed(2)} MHz`;
      ui.kvIons.textContent = `${lab.ionsLoaded}`;
      ui.kvNbar.textContent = `${lab.nbar.toFixed(2)}`;

      // sidebar summary cards
      ui.cardPressure.textContent = lab.pressure.toExponential(2) + ' mbar';
      ui.cardPressureHint.textContent =
        (lab.pressure < 3e-11) ? 'UHV region' :
        (lab.pressure < 2e-10) ? 'OK-ish; collisions possible' :
        'High pressure; expect loss';
      ui.cardIons.textContent = `${lab.ionsLoaded} ions`;
      ui.cardNbar.textContent = `n̄ ≈ ${lab.nbar.toFixed(2)}`;
      ui.cardRF.textContent = `${lab.rf.fMHz.toFixed(1)} MHz @ ${lab.rf.vpp.toFixed(0)} Vpp`;
      ui.cardWz.textContent = `ωz ≈ ${estimateWz().toFixed(2)} MHz`;

      ui.cardSpam.textContent = (lab.readout.lastSpam == null) ? '—' : `${(lab.readout.lastSpam*100).toFixed(2)}%`;
    }

    function laserStep(dt){
      const keys = ['L369','L399','L935','L355','L638'];
      for(const k of keys){
        const L = lab.lasers[k];
        const walk = 0.10 * randn() * Math.sqrt(dt);
        L.err += walk;
        const pull = L.lock ? 1.5 : 0.10;
        L.err += (-L.err) * (1 - Math.exp(-pull*dt));
        if(!L.lock && Math.random() < 0.02*dt){
          L.err += 0.6*randn();
        }
      }

      function upd(k, txt, sp){
        const L = lab.lasers[k];
        txt.textContent = `${L.err.toFixed(3)}`;
        const a = Math.abs(L.err);
        const ok = L.lock && a < 0.35;
        const warn = L.lock && a >= 0.35 && a < 0.8;
        const bad = !L.lock || a >= 0.8;
        sp.classList.toggle('ok', ok);
        sp.classList.toggle('warn', warn);
        sp.classList.toggle('bad', bad);
      }
      upd('L369', ui.txtL369Err, ui.spL369);
      upd('L399', ui.txtL399Err, ui.spL399);
      upd('L935', ui.txtL935Err, ui.spL935);
      upd('L355', ui.txtL355Err, ui.spL355);
      upd('L638', ui.txtL638Err, ui.spL638);
    }

    function openNav(open){
      document.body.classList.toggle('navOpen', !!open);
    }

    function highlightNavActive(id){
      const links = ui.nav?.querySelectorAll('a') || [];
      links.forEach(a => a.classList.remove('active'));
      const match = [...links].find(a => a.getAttribute('href') === `#${id}`);
      if(match) match.classList.add('active');
    }

    function setupScrollSpy(){
      const sections = document.querySelectorAll('section[data-section]');
      if(!sections.length) return;
      const obs = new IntersectionObserver((entries) => {
        // pick the most visible entry
        const best = entries
          .filter(e => e.isIntersecting)
          .sort((a,b) => (b.intersectionRatio - a.intersectionRatio))[0];
        if(best?.target?.id){
          highlightNavActive(best.target.id);
        }
      }, { root: null, threshold: [0.15, 0.25, 0.35, 0.5] });

      sections.forEach(s => obs.observe(s));
      highlightNavActive('section-overview');
    }

    function bindControls(){
      // tooltips toggle preference
      let tipsOn = true;
      try{
        const v = localStorage.getItem('qils_tooltips');
        if(v === '0') tipsOn = false;
      }catch{}
      Tooltip.setEnabled(tipsOn);
      ui.btnTips?.setAttribute('aria-pressed', tipsOn ? 'true' : 'false');
      ui.btnTips?.addEventListener('click', ()=>{
        const current = ui.btnTips.getAttribute('aria-pressed') === 'true';
        const next = !current;
        ui.btnTips.setAttribute('aria-pressed', next ? 'true' : 'false');
        Tooltip.setEnabled(next);
        try{ localStorage.setItem('qils_tooltips', next ? '1' : '0'); }catch{}
        log(`Tooltips ${next ? 'ON' : 'OFF'}.`);
        toast(`Tooltips ${next ? 'ON' : 'OFF'}.`);
      });

      // assign tips once (after tooltip enabled state is known)
      applyTooltips();

      // navigation / overlays
      ui.btnNav?.addEventListener('click', () => openNav(true));
      ui.btnCloseNav?.addEventListener('click', () => openNav(false));
      ui.navOverlay?.addEventListener('click', () => openNav(false));
      document.addEventListener('keydown', (e) => {
        if(e.key === 'Escape'){
          Tooltip.dismiss();
          openNav(false);
          if(ui.dlgHelp?.open) ui.dlgHelp.close();
        }
      });

      // filter panels
      function applyFilter(){
        const q = (ui.txtFilter?.value || '').trim().toLowerCase();
        const panels = document.querySelectorAll('details.panel[data-title]');
        panels.forEach(p => {
          const title = (p.getAttribute('data-title') || '').toLowerCase();
          const show = (!q) || title.includes(q) || p.textContent.toLowerCase().includes(q);
          p.style.display = show ? '' : 'none';
        });
      }
      ui.txtFilter?.addEventListener('input', applyFilter);

      // “go to” buttons
      ui.btnScrollProgram?.addEventListener('click', () => document.querySelector('#section-program')?.scrollIntoView({behavior:'smooth'}));
      ui.btnScrollReadout?.addEventListener('click', () => document.querySelector('#panelReadout')?.scrollIntoView({behavior:'smooth'}));

      // ensure canvases resize when panels open/close
      document.querySelectorAll('details.panel').forEach(d => {
        d.addEventListener('toggle', () => window.dispatchEvent(new Event('resize')));
      });

      // wire top compile/run buttons
      ui.btnCompileTop?.addEventListener('click', () => ui.btnCompile?.click());
      ui.btnRunTop?.addEventListener('click', () => ui.btnRun?.click());

      // help dialog
      const toggleHelp = () => {
        if(!ui.dlgHelp) return;
        if(ui.dlgHelp.open) ui.dlgHelp.close();
        else ui.dlgHelp.showModal();
      };
      ui.btnHelp?.addEventListener('click', toggleHelp);
      document.addEventListener('keydown', (e) => {
        if(e.key === '?' && !e.ctrlKey && !e.metaKey && !e.altKey){
          e.preventDefault();
          toggleHelp();
        }
        if(e.key === 'Enter' && (e.ctrlKey || e.metaKey) && !e.shiftKey){
          e.preventDefault();
          ui.btnRun?.click();
        }
        if(e.key === 'Enter' && (e.ctrlKey || e.metaKey) && e.shiftKey){
          e.preventDefault();
          ui.btnCompile?.click();
        }
      });

      // quick actions click-through
      ui.qaPump?.addEventListener('click', () => ui.btnPump?.click());
      ui.qaBake?.addEventListener('click', () => ui.btnBake?.click());
      ui.qaOven?.addEventListener('click', () => ui.btnOven?.click());
      ui.qaCool?.addEventListener('click', () => ui.btnCool?.click());
      ui.qaLoad?.addEventListener('click', () => ui.btnLoad?.click());
      ui.qaReset?.addEventListener('click', () => ui.btnReset?.click());

      // sliders
      ui.rngPump?.addEventListener('input', () => { lab.pumpSpeed = ui.rngPump.valueAsNumber/100; syncText(); });
      ui.rngOven?.addEventListener('input', () => { lab.ovenSet = ui.rngOven.valueAsNumber/100; syncText(); });

      // trap numbers
      function syncTrap(){
        lab.rf.fMHz = ui.numRFf?.valueAsNumber || lab.rf.fMHz;
        lab.rf.vpp = ui.numRFv?.valueAsNumber || lab.rf.vpp;
        lab.trap.wzMHz = ui.numWz?.valueAsNumber || lab.trap.wzMHz;
        lab.trap.wrMHz = ui.numWr?.valueAsNumber || lab.trap.wrMHz;
        lab.trap.BmT = ui.numB?.valueAsNumber || lab.trap.BmT;
        syncText();
      }
      [ui.numRFf, ui.numRFv, ui.numWz, ui.numWr, ui.numB].forEach(el => el?.addEventListener('input', syncTrap));

      // readout
      ui.rngLLR?.addEventListener('input', ()=>{ ui.txtLLR.textContent = (ui.rngLLR.valueAsNumber||0).toFixed(1); });

      // camera
      ui.selCamMode?.addEventListener('change', ()=>{ lab.cam.mode = ui.selCamMode.value; });
      ui.rngCamGain?.addEventListener('input', ()=>{ lab.cam.gain = ui.rngCamGain.valueAsNumber; ui.txtCamGain.textContent = lab.cam.gain.toFixed(1); });
      ui.rngCamSigma?.addEventListener('input', ()=>{ lab.cam.sigma = ui.rngCamSigma.valueAsNumber; ui.txtCamSigma.textContent = lab.cam.sigma.toFixed(1); });
      ui.numCamScale?.addEventListener('input', ()=>{ lab.cam.scaleUmPerPx = ui.numCamScale.valueAsNumber || 1.2; });
      ui.numCamROI?.addEventListener('input', ()=>{ lab.cam.roiHalf = ui.numCamROI.valueAsNumber || 14; });
      ui.selCamOverlay?.addEventListener('change', ()=>{ lab.cam.overlay = ui.selCamOverlay.value; });

      // vacuum buttons
      ui.btnPump?.addEventListener('click', ()=>{
        lab.pumpOn = !lab.pumpOn;
        log(`Pump ${lab.pumpOn?'ON':'OFF'}`);
        toast(`Pump ${lab.pumpOn?'ON':'OFF'}`);
        syncToggles();
      });
      ui.btnBake?.addEventListener('click', ()=>{
        lab.bakeOn = !lab.bakeOn;
        log(`Bake ${lab.bakeOn?'ON':'OFF'}`);
        toast(`Bake ${lab.bakeOn?'ON':'OFF'}`);
        syncToggles();
      });
      ui.btnOven?.addEventListener('click', ()=>{
        lab.ovenOn = !lab.ovenOn;
        log(`Oven ${lab.ovenOn?'ON':'OFF'}`);
        toast(`Oven ${lab.ovenOn?'ON':'OFF'}`);
        syncToggles();
      });
      ui.btnLoad?.addEventListener('click', ()=>{
        const n = clamp(ui.numQ?.valueAsNumber || 4, 1, 16)|0;
        lab.ionsLoaded = n;
        lab.ions = makeIonChain(n);
        log(`Loaded ion chain: N=${n}`);
        toast(`Loaded ions: N=${n}`);
      });
      ui.btnCool?.addEventListener('click', ()=>{
        lab.coolingOn = !lab.coolingOn;
        log(`Cooling ${lab.coolingOn?'ON':'OFF'}`);
        toast(`Cooling ${lab.coolingOn?'ON':'OFF'}`);
        syncToggles();
      });
      ui.btnReset?.addEventListener('click', ()=>{
        Object.assign(lab, {
          pressure: 1e-9,
          ovenTempC: 25,
          ionsLoaded: 0,
          ions: [],
          nbar: 8.0,
          pumpOn:false,
          bakeOn:false,
          ovenOn:false,
          coolingOn:false,
          readout: { lastBrightCounts:[], lastDarkCounts:[], lastSpam:null },
          cal: { points:[], tableRows:[] },
          cam: { ...lab.cam, lastImage:null, lastCounts:null, centroid:null },
        });
        ui.tblOut.innerHTML = '';
        ui.tblCal.innerHTML = '';
        log('Reset.');
        toast('Reset.');
        syncToggles();
      });

      // program templates
      ui.selTemplate?.addEventListener('change', ()=>{
        ui.txtProgram.value = templates[ui.selTemplate.value] || '';
      });

      ui.btnCompile?.addEventListener('click', ()=>{
        try{
          const text = ui.txtProgram.value || '';
          const ops = compileProgram(text);
          lab.program.text = text;
          lab.program.compiled = ops;
          lab.program.lastError = null;
          drawPulseTimeline(ops);
          setReady('ok', 'COMPILED');
          log(`Compiled ${ops.length} ops.`);
          toast(`Compiled ${ops.length} ops.`);
        }catch(e){
          lab.program.lastError = e;
          setReady('bad', 'ERROR');
          log(`Compile error: ${e.message}`);
          toast(`Compile error: ${e.message}`);
        }
      });

      ui.btnRun?.addEventListener('click', ()=>{
        try{
          const text = ui.txtProgram.value || '';
          const ops = compileProgram(text);
          lab.program.text = text;
          lab.program.compiled = ops;
          lab.program.lastError = null;

          runShots(ops);
          setReady('ok', 'RAN');
        }catch(e){
          setReady('bad', 'ERROR');
          log(`Run error: ${e.message}`);
          toast(`Run error: ${e.message}`);
        }
      });

      // lasers
      function syncLocks(){
        lab.lasers.L369.lock = ui.chkL369.checked;
        lab.lasers.L399.lock = ui.chkL399.checked;
        lab.lasers.L935.lock = ui.chkL935.checked;
        lab.lasers.L355.lock = ui.chkL355.checked;
        lab.lasers.L638.lock = ui.chkL638.checked;
      }
      [ui.chkL369,ui.chkL399,ui.chkL935,ui.chkL355,ui.chkL638].forEach(el=>el?.addEventListener('change', syncLocks));

      ui.btnLockAll?.addEventListener('click', ()=>{
        [ui.chkL369,ui.chkL399,ui.chkL935,ui.chkL355,ui.chkL638].forEach(el=>el.checked=true);
        syncLocks();
        log('Lasers: lock all.');
        toast('Lasers: lock all.');
      });
      ui.btnUnlockAll?.addEventListener('click', ()=>{
        [ui.chkL369,ui.chkL399,ui.chkL935,ui.chkL355,ui.chkL638].forEach(el=>el.checked=false);
        syncLocks();
        log('Lasers: unlock all.');
        toast('Lasers: unlock all.');
      });
      ui.btnKickLasers?.addEventListener('click', ()=>{
        for(const k of ['L369','L399','L935','L355','L638']){
          lab.lasers[k].err += 0.9*randn();
        }
        log('Lasers: kick.');
        toast('Lasers: kick.');
      });

      // micromotion
      function syncMM(){
        lab.mm.compX = ui.numCompX?.valueAsNumber || 0;
        lab.mm.compY = ui.numCompY?.valueAsNumber || 0;
      }
      ui.numCompX?.addEventListener('input', syncMM);
      ui.numCompY?.addEventListener('input', syncMM);
      ui.btnAutoMM?.addEventListener('click', ()=>{
        lab.mm.compX *= 0.55;
        lab.mm.compY *= 0.55;
        ui.numCompX.value = lab.mm.compX.toFixed(2);
        ui.numCompY.value = lab.mm.compY.toFixed(2);
        log('Micromotion: auto step toward optimum.');
        toast('Micromotion: auto step toward optimum.');
      });

      // base select
      ui.selBaseP?.addEventListener('change', ()=>{ lab.baseP = parseFloat(ui.selBaseP.value); });

      // log actions
      ui.btnClearLog?.addEventListener('click', ()=>{
        ui.log.textContent = '';
        toast('Log cleared.');
      });
      ui.btnCopyLog?.addEventListener('click', async ()=>{
        try{
          await navigator.clipboard.writeText(ui.log.textContent || '');
          toast('Log copied to clipboard.');
        }catch{
          toast('Clipboard unavailable.');
        }
      });

      // init template text
      ui.txtProgram.value = templates[ui.selTemplate.value] || templates.ramsey;
      syncLocks();
      syncTrap();
      syncMM();
      syncToggles();
      syncText();
    }

    /********************
     * Main loop
     ********************/
    function tick(){
      const t = nowMs();
      const dt = Math.min(0.05, (t - lab.last)/1000);
      lab.last = t;
      lab.t += dt;

      pressureUpdate(dt);
      ovenUpdate(dt);
      ionsUpdate(dt);
      laserStep(dt);

      // readiness
      const okVac = lab.pressure < 2.5e-10;
      const okIons = lab.ionsLoaded > 0;
      if(okVac && okIons) setReady('ok', 'READY');
      else setReady(okVac ? 'warn' : 'bad', okVac ? 'NO IONS' : 'VAC');

      syncText();

      drawVacuum();
      drawIons();
      drawPulseTimeline(lab.program.compiled);
      drawReadout(lab.readout.lastBrightCounts, lab.readout.lastDarkCounts);
      drawCamera();
      drawPhotonTrace();
      drawLaserDiag();
      drawMM();
      drawCalibration();
      drawMS();

      requestAnimationFrame(tick);
    }

    // Resize handler
    window.addEventListener('resize', ()=>{
      refreshColors();
      [
        ui.cvEnv, ui.cvIons, ui.cvPulse, ui.cvReadout, ui.cvDist, ui.cvCam,
        ui.cvPhoton, ui.cvMS, ui.cvLaser, ui.cvMM, ui.cvCal
      ].forEach(ensureCanvas);
    });

    // Boot
    bindControls();
    setupScrollSpy();
    log('Simulator ready.');
    toast('Simulator ready.');
    requestAnimationFrame(tick);
  </script>
</body>
</html>
